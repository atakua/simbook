% Copyright (c) 2016 Grigory Rechistov <grigory.rechistov@gmail.com>
% This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Worldwide.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/.

\chapter[Альтернативы симуляции]{Альтернативные подходы к~изучению цифровых систем}\label{alternatives}

\dictum[Raj Jain]{Contrary to common belief, performance evaluation is an art\footnotemark.}
\footnotetext{Вопреки общепринятому мнению, измерение производительности — это искусство.}

Было бы неверным полагать, что симуляция является единственным, оптимальным и незаменимым инструментом анализа поведения вычислительных систем. Существуют другие методики анализа поведения иерархических систем, к которым относятся  в том числе вычислительные машины. 

В данной главе мы рассмотрим два подхода, призванных отвечать на вопрос: какие значения выходных характеристик функционирования системы мы получим, если в качестве входных данных подадим некоторые другие, экспериментально полученные числа? 

\section[Сети массового обслуживания]{Сети массового обслуживания}

Эта методика (\abbr queuing networks)~\citep{qsp} названа по своему основному инструменту — направленному графу (сети), в узлах которого находятся автономные части изучаемой аппаратной системы. Анализ заключается в выполнении следующих шагов.

\begin{enumerate*}
\item Обрисовка схемы функционирования системы с помощью диаграммы обслуживания, отражающей наличие в ней клиентов, (опционально) прибывающих снаружи, перемещающихся по центрам обслуживания и затем (опционально) убывающих из неё или возвращающихся к началу (рис.~\ref{fig:qsp}). Пример явления, описываемого такой схемой, — очередь на регистрацию на авиарейс; при этом люди в очереди — это клиенты, а стойка регистрации — центр обслуживания. Если при этом багаж пассажирам приходится сдавать в отдельном месте, то багажная стойка также является центром обслуживания (заметьте, что у неё тоже может образоваться очередь).

\newcommand{\queuenode}[0]{%
\begin{tikzpicture}
    \draw (-0.2,1) -- +(0.2, 0) -- +(0.2, -1) -- +(-0.1, -1) node[midway] {};
    \draw (0.5,0.5) circle (0.5cm);
\end{tikzpicture}
}

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.8\textwidth]{./qsp-crop.pdf}
    \begin{tikzpicture}[>=latex, node distance = 2cm, font=\small]
    
    \node[text width=2.5cm] (inclients) {Прибывающие клиенты};
    
    \node[right of=inclients, xshift=1cm]  (cpu) {\queuenode};
    \node[above of=cpu, node distance = 0.8cm] {ЦПУ};
    
    \node[right of=cpu, xshift=2cm]    (chan2) {\queuenode};
    \node[above of=chan2]  (chan1) {\queuenode};
    \node[below of=chan2]  (chan3) {\queuenode};
    \node[above of=chan1, node distance = 0.8cm] {Каналы памяти};
    
    \draw[->] (inclients.center) -- (cpu.west) node[midway] (returnpoint) {};
    \path (cpu.east) -- +(1,0) coordinate (divergepoint) node[pos=0.25] (leavepoint) {};
    
    \draw[->]  (cpu.east) -- (chan2.west);
    \draw[->]  (divergepoint) -- (chan1.west);
    \draw[->]  (divergepoint) -- (chan3.west);
    \draw[->] (leavepoint.center) -- +(0, 1.5cm) node[above] {Уходящие клиенты};
    \path ([yshift=-1cm, xshift=1cm] chan3) coordinate (turnpoint);
    \draw[->] (chan1.east) -| +(+0.5,0) |- (turnpoint) -| (returnpoint);
    \draw[->] (chan2.east) -| +(+0.5,0) |- (turnpoint) -| (returnpoint);
    \draw[->] (chan3.east) -| +(+0.5,0) |- (turnpoint) -| (returnpoint);
    
    \end{tikzpicture}
    \caption[Пример представления системы в виде сети обрабатывающих центров]{Пример представления системы в виде сети обрабатывающих центров. Стрелками показаны направления прибытия, отправления и перемещения клиентов; кружками — обслуживающие центры, прямыми скобками — очереди, в которых могут находиться клиенты, ожидающие сервиса}
    \label{fig:qsp}
\end{figure}


\item Нахождение входных величин, описывающих известные параметры функционирования системы или её частей. Они берутся из внешних источников, например, из эксперимента или документации.

\item Использование законов поведения системы обслуживания для нахождения неизвестных характеристик поведения.
\end{enumerate*}

Понятия, которыми оперирует методика анализа сетей обслуживания, в основном характеризуют или скорость совершения каких-либо действий в центре обслуживания, или время неких процессов, происходящих с одним потребителем. При этом она описывает установившиеся состояния систем, при которых величины не изменяются во времени, и призвана описывать средние величины для статистических популяций клиентов.

Основные понятия, вводимые для описания состояния системы и её частей, и их обозначения приведены далее.

\begin{itemize*}
\item 
Скорость прибытия (\abbr arrival rate) $\lambda$ — как часто возникают новые запросы/потребители.

\item 
Темп передачи\footnote{Величина, часто также называемая пропускной способностью.} (\abbr throughput) $X$ — как быстро некоторый центр способен их обслуживать.

\item 
Степень утилизации (\abbr utilization) $U$ — доля времени, в течение которой центр занят обслуживанием.

\item 
Среднее время обслуживания запроса (\abbr service requirement per request) $S$ — сколько один потребитель находится в некотором центре.
\end{itemize*}

Следующим компонентом подхода являются законы, связывающие величины. Зачастую  они легко выводятся из общих соображений, которые имеют все люди, когда либо пытавшиеся получить какую-либо услугу в любой бюрократической организации этого мира и пытавшиеся облегчить свою участь.

\begin{itemize*}
\item Закон использования (The utilization law): $U = X \cdot S $.

\item Закон Литтла (\abbr Little's law): среднее число $N$ клиентов за достаточно долгосрочный период в устойчиво функционирующей системе  равно средней норме или скорости прибытия, умноженной на определённое за тот же период среднее время $T$, которое один клиент проводит в системе: $N = \lambda T$.

Одно из следствий этого закона позволяет понять, как можно «выменивать» пропускную способность на задержку при передаче сообщений: в одной и той же системе мы можем или послать одно большое сообщение, состоящее из нескольких маленьких, за один раз  и достаточно быстро, однако после этого вынуждены ожидать, пока это комбинированное сообщение придёт к отправителю, или же отправлять их сразу по готовности, при этом каждое будет вызывать достаточно длинную задержку.


\item Соотношение для времени отклика системы: $R = N/X - Z$. Данное соотношение связывает ощущаемое клиентом время ожидания $R$, количество клиентов $N$,~~пропускную способность узла $X$ и время <<размышления>> клиента $Z$, в течение которого он сам по себе не требует немедленного сервиса.


\item Закон вынужденного потока (\abbr the forced flow law) выражает пропорциональность загруженности подсистем полной пропускной способности всей системы при условии ненасыщенного состояния отдельных центров: $X_k = V_k X$.

\item 
Баланс потока: $\lambda = X$ — по сути переформулировка понятия устоявшегося режима, при котором число клиентов в системе постоянно и лишь слабо флуктуирует в моменты переходов клиентов между центрами.
\end{itemize*}

Несмотря на простоту используемых формул, при умелом построении схемы и правильном использовании методика позволяет достаточно точно, а главное быстро, без использования большого количества вычислений, предсказывать характер поведения комплекса при изменении его характеристик и, в частности, давать ответы на следующие вопросы:

\begin{enumerate*}
\item Как изменится производительность при увеличении или изменении характера нагрузки?

\item Как отразится модификация подсистемы (например, апгрейд) на работу целого~\citep{tulchinski2012}?

\item Будет ли получен эффект от удвоения (утроения, уменьшения\dots) числа  обслуживающих центров при неизменности прочих компонент?
\end{enumerate*}

Одна из мощных методик, построенных на теории центров обслуживания, имеет название анализ \textit{средних значений} (\abbr mean value analysis, MVA). Характерной её особенностью является решение системы уравнений, связывающих искомые и известные величины численными итеративными методами.

\section{Симуляция методами Монте-Карло}

Все описанные ранее алгоритмы симуляции (интерпретация, двоичная трансляция и т.п.) обладали одним общим свойством — они были детерминированными, как и описываемые ими цифровые системы. При этом строгая повторяемость результатов,  как правило, является предметом гордости её авторов. Несмотря на это, в науке существует широкий класс методик, основанных на принципиальной случайности ряда входных или промежуточных величин. Класс таких методов моделирования получил название \textit{Монте-Карло} в честь города с большим количеством казино, где случай решает всё.

Анализ с помощью очередей и центров обслуживания имеет свои основания в теории стохастических процессов, применённой к процессу вычислений~\citep{allen1990}. При этом используются \emph{частные} выводы из общих результатов, верные для стационарных процессов и установившихся состояний. Исследование, явным образом учитывающее случайность <<мгновенных>> значений входных данных, даёт возможность изучить поведение более детально, в частности, <<увидеть>> переходные процессы, измерить реакцию системы на задачах, различающихся не только своими макрохарактеристиками (средняя интенсивность), но и статистическими параметрами, учесть нелинейный характер отдельных элементов системы и т.п.
 
Общая схема моделирования с использованием методов Монте-Карло выглядит следующим образом:

\begin{enumerate*}
\item Построить функцию, описывающую поведение интересующей нас системы и зависящую от ряда входных параметров. Функция также может зависеть от результатов предыдущих её запусков (например, быть марковским процессом).

\item Провести акт симуляции системы, заключающийся в генерации набора случайных входных данных и вычисления на них функции системы.

\item Повторить симуляции большое количество раз для достижения статистически значимых результатов.

\item Усреднить отдельные результаты актов симуляции для получения конечных чисел, характеризующих систему.
\end{enumerate*}

Использование случайных последовательностей отражает тот факт, что не всегда мы имеем информацию о точной последовательности внешних воздействий на систему, а лишь некие усреднённые величины; кроме того, иногда точность принципиально недостижима или даже вредна: например, мы хотим знать поведение на обширном классе задач, при этом предварительно составлям его статистический <<портрет>> и затем исполняем свою модель с его учётом. 

Методы Монте-Карло относительно слабо используются в исследованиях отдельных вычислительных систем в настоящее время, т.к. имитационная симуляция в большинстве случаев может быть выполнена быстро и дать более точные данные о работе приложения, не обезличенные усреднением. Однако она перестаёт быть лучшим решением в случаях, когда исследователя интересуют системы гигантских размеров (миллионы и миллиарды агентов: процессоров, ядер, узлов и т.п.). При этом нет возможности проследить за всеми переходами в её глобальном состоянии и одновременно нет удобных способов применить декомпозицию для изучения подсистем. Построение детальной имитационной модели не представляется возможным, поэтому ограничиваются более-менее высокоуровневыми описаниями. Один из примеров практических реализаций — пакет для моделирования сетей NS-3~\citep{ns}.

Существенное достоинство методик, использующих случайные числа, — эффективность параллельной симуляции отдельных экспериментов, т.к. они совершенно независимы друг от друга: их входные данные не связаны между собой, а состояние системы может зависеть только от предыдущего её состояния~\citep{glinsky2011}. Это обстоятельство открывает путь к практически линейному ускорению симуляции при увеличении числа используемых вычислительных узлов.

Однако при этом строгие требования  выдвигаются на используемый генератор случайных чисел (ГСЧ, \abbr RNG, random number generator). Он должен обладать следующими свойствами:
\begin{enumerate*}
\item Случайность и взаимная независимость генерируемых величин на всех потоках симуляции. Нарушение этого условия может привести к серьёзным искажениям результатов эксперимента.
\item Высокая скорость создания случайной последовательности и доставки её членов до потребителей. Невыполнение этого требования делает генератор случайных чисел узким местом, ограничивающим выигрыш от параллелизма.
\end{enumerate*}

Для генерации случайных последовательностей могут использоваться аппаратные ГСЧ. Они могут быть выполнены в качестве плат расширения (PCI, PCI-Express и т.п.) или входить в состав системной логики материнской платы или в ядро центрального процессора. Например, в процессоры микроархитектуры Ivy Bridge компании Intel была включена инструкция \texttt{RDRAND}~\citep{bull-mountain, ieee-rng}, возвращающая 64-битные случайные числа, пригодные в том числе для задач криптографии. 

Также могут быть использованы генераторы псевдослучайных последовательностей (ГПСЧ, \abbr PRNG, pseudo-random number generator). О существующих подходах к их построению, истории неудачных решений, тестировании качества подробно рассказывается в~\cite[глава 5]{simulation-handbook}.

%\input{alternatives-questions}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

