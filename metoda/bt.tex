% Copyright (c) 2016 Grigory Rechistov <grigory.rechistov@gmail.com>
% This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Worldwide.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/.

\chapter{Улучшенные техники моделирования процессора}\label{bt}

%by German philosopher Arthur Schopenhauer:
%“All truth passes through three stages. First, it is ridiculed. Second, it is violently opposed. Third, it is accepted as being self-evident.”
% Paniccia says if you believe in something, “Fight to stay in the game long enough to prove it.”

\dictum[Аркадий и Борис Стругацкие. Понедельник начинается в субботу]{Лично я вижу в этом перст судьбы — шли по лесу и встретили программиста.}

Рассмотрим принципы и алгоритмы, лежащие в основе таких методов симуляции, как двоичная трансляция и прямое исполнение, в том числе с аппаратной поддержкой. В конце главы описывается, как можно сочетать лучшие стороны всех рассмотренных подходов в составе одного симулятора.

\section{Двоичная трансляция}

Как было показано в предыдущей главе, симулирование исполнения процессора через интерпретацию обладает как положительными качествами, такими как простота разработки и модификации, так и существенным недостатком — очень низкой скоростью работы получаемой модели, зачастую недостаточной для практического применения. Так, загрузка операционной системы на интерпретирующем симуляторе может занять дни.

Как и в случае с исполнением программ, написанных на языках высокого уровня, имеется следующее решение: вместо того, чтобы на каждом шаге анализировать текст, мы единожды компилируем его в машинный код и затем запускаем полностью подготовленную программу. При этом нет необходимости в перекомпиляции перед каждым запуском.

Если взять набор инструкций целевой машины за входной язык, а инструкции хозяйской машины — за выходной, то можно попытаться «скомпилировать» блоки целевого кода один раз и затем многократно переиспользовать результаты этой работы. При этом исчезает необходимость обращаться к интерпретации инструкций на каждом шаге исполнения.

Подобный процесс получил собственное название \textit{двоичная трансляция} (\textit{ДТ}, также \textit{бинарная трансляция}, \textit{БТ}, \abbr binary translation, BT)~\citep{bt1993}. Несмотря на концептуальную схожесть с компиляцией языков высокого уровня, двоичная трансляция имеет существенные особенности, во многом связанные с тем фактом, что исходный для неё язык — машинный код целевой архитектуры — в отличие от языков высокого уровня содержит гораздо меньше информации об алгоритме программы и при этом может быть нагружен различными индивидуальными ограничениями гостевой архитектуры, затрудняющими эффективную трансляцию и повышающими трудоёмкость написания транслятора.

\subsection{Преобразование гостевого кода}

Общий принцип ДТ состоит в том, что на некотором этапе работы транслятора для блока инструкций, взятых из гостевого приложения и принадлежащих гостевому ISA, в процессе трансляции создаётся новый блок, использующий хозяйские инструкции. Результаты исполнения гостевого кода на гостевой системе и транслированного на хозяйской должны совпадать, т.е. быть семантически эквивалентны. Одновременно могут существовать несколько блоков трансляции, соответствующих разным секциям исходного кода. Каждый их них имеет минимум одну точку входа — адрес, с которого содержащийся в нём код должен начинать исполняться, — и несколько (по крайней мере одну) точек выхода, соответствующих различным ситуациям, при которых симуляция его покидает.

Отдельные блоки трансляции могут быть связаны вместе с помощью \textit{клея} (\abbr glue code), т.е. кода, не соответствующего никакому гостевому, но необходимого для передачи управления между блоками. На рис.~\ref{fig:bb-translation} показано, как связаны части исходного кода гостевой программы и результат трансляции, состоящий из хозяйских инструкций.

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/bb-translation}
    \caption[Исходный код и результат трансляции]{Исходный код базового блока приложения и его связь с результатом двоичной трансляции. Штриховыми линиями показаны точки входа и выхода}
    \label{fig:bb-translation}
\end{figure}


\subsection{Пример преобразования одной инструкции}

На рис.~\ref{fig:capsule} приведён пример соответствия гостевой 64-битной инструкции процессора архитектуры Intel\textregistered EM64T и блока хозяйского кода, называемого \textit{капсулой} или сервисной процедурой (\abbr service routine), хозяйского процессора, поддерживающего только 32-битные инструкции Intel\textregistered IA-32. 

%Исполнение инструкции подразумевает чтение операнда из памяти с сопутствующей этому процедуре операции преобразования адресов. Затем с помощью двух 32-битных команд выполняется 64-битное сложение. Результат помещается в области памяти, хранящей архитектурное состояние моделируемого устройства; в данном случае на начало её указывает хозяйский регистр \texttt{EBP}, а смещения полей задаются константами времени компиляции \texttt{RAX\_OFF, RBX\_OFF}  и т.п.


\begin{figure}[htb]
    \centering
    \inputpicture{drawings/capsule}
    \caption[Пример соответствия гостевой инструкции и хозяйской капсулы]{Пример соответствия гостевой инструкции и хозяйской капсулы, эмулирующей её семантику и написанной на языке ассемблера. В этом примере хозяйский регистр \texttt{EBP} хранит указатель на структуру гостевого состояния, макросы вида \texttt{RxX_OFF} — смещение внутри гостевого состояния для регистра RxX, а \texttt{v2h} — функция преобразования виртуальных гостевых адресов в хозяйские}
    \label{fig:capsule}
\end{figure}

\paragraph{Доступ к гостевым регистрам.}

В рассматриваемом примере используется массив в памяти, различные ячейки которого хранят гостевые регистры. Хозяйский регистр \texttt{EBP} указывает на начало этого массива. По некоторому смещению от его начала, обозначенному \texttt{RAX_OFF}, хранится значение гостевого регистра \texttt{RAX} (строки (6) и (7)), \texttt{RBX_OFF} — смещение для регистра \texttt{RBX} и .т.д. Для того, чтобы выполнить операцию сложения, содержимое памяти загружается в пару 32-битных регистров EDX, EBX (строки (4) и (5)).

\paragraph{Выполнение операции.}
Поскольку в наборе инструкций IA-32 нет инструкций для операции с 64-битными числами, сложение проводится в два этапа. Сначала складываются младшие 32 бита операндов с помощью инструкции \texttt{ADDL} строка (6). Затем — старшие 32 бита с учётом возможного флага переноса разряда от предыдущего сложения с помощью \texttt{ADDCL}, строка (7).

\paragraph{Чтение гостевой памяти.}

Ситуация с обращениями к гостевой памяти несколько сложнее. Для её моделирования уже недостаточно просто завести массив в памяти. В общем случае связь гостевых данных и их положения в хозяйском пространстве памяти нелинейна и сложна. В нашем примере это отражено тем, что, перед тем как загрузить первый операнд, вызывается функция \texttt{v2h}, строка (3), единственный аргумент которой сохранён в стеке, строки (1) и (2). Подробнее о том, что эта функция выполняет, рассказывается в главе~\ref{state}.

Последняя хозяйская инструкция продвигает симулируемый регистр \texttt{RIP} на длину только что обработанной (3 байта) так, чтобы он указывал на начало следующей инструкции (строка (8)).

\subsubsection{Размер капсулы}
Для «идеального» ДТ для некоторой пары архитектур желательно выдерживать соответствие «одна хозяйская инструкция эмулирует одну гостевую» для каждой капсулы. Из-за неполного соответствия окружений гостя и симулятора это почти никогда не выполняется, возможны следующие ситуации.

\begin{enumerate*}
    \item На одну гостевую приходится несколько хозяйских инструкций, в сумме компенсирующих различия между архитектурами.
    \item На одну гостевую приходится ноль хозяйских инструкций. Такая ситуация возникает, если исходная команда не изменяет архитектурного состояния и может быть опущена в функциональной модели. Примеры: операции предвыборки в кэш, подсказки для предсказателя переходов.
    \item Соединяющий блоки трансляции клей не соответствует ни одной гостевой инструкции и необходим только для работы симулятора.
\end{enumerate*}


\subsection{Особенности реализации ДТ}

Разумно ожидать, что чем больше похожи целевая и хозяйская архитектура, тем проще создавать ДТ и тем быстрее он должен работать. Для особого случая, когда эти архитектуры совпадают, может оказаться, что никакого преобразования производить и не требуется — целевой код уже «готов» для исполнения (см. секцию~\ref{sec:dex} о  преградах на пути к такому бесхитростному подходу). Верно и обратное — чем сильнее различаются архитектуры гостя и хозяина, тем больше усилий приходится вкладывать в реализацию ДТ и симулятора в целом.

\subsubsection{Семантика инструкций}

Всё множество команд современных процессоров можно разделить на несколько классов согласно выполняемой ими функции. Расcмотрим особенности, характерные для симуляции инструкций каждого из них.

\begin{description*}
    \item[Арифметические целочисленные.] Практически все существующие ISA имеют команды для арифметических, логических и сдвиговых операций над целыми числами, и их эффективное моделирование в составе ДТ, как правило, вызывает минимальные проблемы.
    
    \item[Инструкции с числами с плавающей запятой.] Поддержка разными процессорами существенно различается, несмотря на наличие стандарта IEEE 754~\citep{ieee754}, призванного внести унификацию. Некоторые архитектуры могут оперировать числами только одинарной (32 бита) или двойной (64 бита) точности. Другие используют нестандартные форматы, например, сопроцессор x87 IA-32 использует внутреннее представление чисел шириной 80 бит, а в IA-64 машинный формат чисел — 82 бита. Машинная поддержка половинной (16 бит) и четырёхкратной (128 бит) точности, а также форматов с основанием десять присутствует в ограниченном числе систем.
    Кроме представления чисел, сами арифметические операции могут быть реализованы по-разному. Они различаются доступными режимами округления результатов, способами индикации ошибочных ситуаций, поведением для \textit{денормализованных} (\abbr denormalized) чисел и т.д. Интересующийся читатель найдёт подробное описание в~\citep{MullerEtAl2010}. Библиотека SoftFloat~\citep{softfloat} реализует стандарт IEEE 754 с помощью только целочисленной арифметики, тем самым предоставляя переносимую реализацию.
    
    \item[Векторные инструкции.] Используются для параллельного выполнения операции над векторами значений, хранящихся в специальных регистрах шириной до 512 бит. Примеры: Intel\textregistered~SSE, AVX, AVX2, IBM AltiVec~\citep{altivec}. При симуляции в случае, если хозяин не имеет аналогичной инструкции, она может быть представлена с помощью последовательного выполнения операции над всеми элементами вектора. Таким образом, векторные операции сводятся к своим последовательным вариантам.
    
    \item[Контроль управления.] В этот класс включаются инструкции, изменяющие значение указателя текущей команды \texttt{PC}, т.е. условные и безусловные переходы, вызовы процедур и возвращения из них, программного прерывания и т.д. В разных архитектурах они отличаются очень сильно. Поэтому чаще всего их капсулы получаются достаточно длинными. Общая задача симулятора при их обработке — вычисление точки входа в новый блок трансляции, соответствующий гостевому адресу перехода. При этом приходится учитывать возможность ситуации, в которой она отсутствует или некорректна. %Более подробно вопрос обработки переходов в гостевом коде рассматривается в секции~\ref{sec:linking}
    
    \item[Привилегированные инструкции.] В большинстве архитектур некоторая часть команд может исполняться, только если процессор находится в специальном режиме, иначе они вызывают исключение. В этом режиме работает операционная система, имеющая неограниченный доступ ко всем ресурсам системы. Привилегированные инструкции специфичны для каждой системы и обычно семантически нагружены, поэтому их симуляция требует длинных капсул.
    
    Ситуация не улучшается даже при полном совпадении архитектур гостя и хоязина. Так как исполнение привилегированных команд в непривилегированном режиме, в котором обычно работает сама программа-симулятор, невозможно, их приходится заменять последовательностью разрешённых инструкций. Более подробно этот вопрос разбирается в главе~\ref{virt}.

    \item[Прочие.] Существует достаточно много инструкций различных ISA, не подпадающих под данную выше классификацию или имеющих специфику, требующую особого внимания при симуляции. Это могут быть строковые, предикатные, длинные инструкций, слоты задержки у переходов и т.п.
\end{description*}


\subsubsection{Сходства и различия в архитектурных состояниях}

Хранение состояния целевой системы в выделенном буфере памяти обладает недостатком — необходимостью часто обращаться к медленному ОЗУ и испытывать большие задержки при промахах кэша. Поэтому создатели систем ДТ стараются разместить максимально возможное число целевых регистров на хозяйских, чтобы при обращении к ним требовалось минимальное время. Это легко осуществить, если в архитектуре хозяина предусмотрено большее число регистров, чем необходимо гостю. Например, это верно для комбинации гостевой системы IA-32 c 8 регистрами общего назначения и хозяина архитектуры MIPS с 31 регистром. При этом максимальная ширина доступных регистров также может различаться. Например, для модели 64-битной архитектуры IA-64 не получится уместить гостевой регистр целиком в хозяйском, если хозяйская система — 32-битная, например, ARMv7.

Если эти условия на регистровый файл не выполняются, то приходится прибегать к различным ухищрениям. Так, только часть регистров может быть отдана под нужды симуляции, а один гостевой регистр приходится «разбивать» на несколько частей, по отдельности умещающихся в хозяйских. См. также главу~\ref{state}, в которой подробнее разбираются вопросы моделирования состояния.

\subsection[Статическая и динамическая двоичная трансляция]{Статическая и динамическая двоичная трансляция}

Попытаемся ответить на два следующих вопроса.
\begin{enumerate*}
    \item Какой должна быть единица ДТ? Другими словами, чем определяется количество и расположение целевых инструкций, обрабатываемых за один проход транслятора?
    \item Как должны быть связаны во времени фазы трансляции и симуляции? Должна ли одна из них предшествовать второй, или они должны чередоваться?
\end{enumerate*}

Для обычных языков высокого уровня ответ на первый вопрос почти очевиден — исходный файл с текстом программы (или модуля) компилируется в приложение (объектный файл), самодостаточное в плане дальнейшего исполнения или использования. Более мелкие единицы компиляции, такие как процедуры, также имеет смысл транслировать целиком, так как при их использовании понадобится весь их код.

В случае ДТ возникают сложности из-за того, что входной текст таких систем — «монолитный» машинный код, не имеющий меток начала отдельных субъединиц, зачастую с перемешанными секциями кода и данными, неопределёнными адресами переходов и т.п.

\paragraph{Статическая ДТ.} Хотя аналогичная компиляции техника трансляции гостевого приложения целиком в образ хозяйского кода (статическая ДТ) иногда применялась~\citep{Ray97digitalfx32}, она не получила широкого распространения по ряду причин.

Будучи применимым для трансляции отдельных пользовательских приложений, статическая ДТ становится невозможной в случае полноплатформенной симуляции, при которой пришлось бы транслировать всю гостевую память. Во-первых, объём входного текста может быть огромен, и время трансляции, и размер результирующего файла окажутся непозволительно большими. Во-вторых, содержимое памяти, в том числе секций с кодом, изменяется в ходе работы (см. также дальше секцию «\nameref{sec:smc}»), что делает статическую ДТ бессмысленной — результирующий код в силу своей неизменности не будет отражать правильное состояние изменяемой памяти.

С другой стороны, будучи однажды полученным и сохранённым в файле на диске, результат статического преобразования приложения может запускаться неограниченное число раз, что компенсирует время, потраченное на его получение. Поэтому на этапе ДТ могут быть применены разнообразные оптимизации, нацеленные на создание максимально эффективного кода (см. секцию~\ref{sec:optimisations}).

\paragraph{Динамическая ДТ.} Для задач симуляции более адекватным является иной подход, в котором моделирование гостевой системы (то есть исполнение оттранслированного кода) перемежается с запусками механизма двоичной трансляции для новых блоков кода, которые будут вскоре исполнены, а также с обновлениями трансляций для блоков, изменивших своё содержимое. При этом в памяти симулятора хранятся ранее оттранслированные секции для их переиспользования в случае, если управление вновь перейдёт на них (рис.~\ref{fig:dynamic-bt}).

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/dynamic-bt}
    \caption[Динамическая ДТ]{Динамическая ДТ. Фаза симуляции, использующая сгенерированный код, периодически сменяется фазой трансляции, хранящей уже существующие  и создающей новые секции хозяйского кода из гостевого}
    \label{fig:dynamic-bt}
\end{figure}

Отметим, что, в отличие от статической, при динамической ДТ время, потраченное на фазу преобразования, фактически отнимается у фазы симуляции, т.е. негативно сказывается на производительности модели. Поэтому спектр возможных оптимизаций более ограничен, использованы могут быть только достаточно быстрые из них. См. также секцию~\ref{sec:parallel-bt}.

\paragraph{Обнаружение кода.} Следующие обстоятельства необходимо учитывать в процессе трансляции блоков инструкций.

\begin{itemize*}
    \item В оперативной памяти данные программ (переменные, массивы, константы, строки и т.д.) и код (инструкции), их обрабатывающий, хранятся вместе. В общем случае никаких границ между ними не обозначено. Трансляция секций данных бесполезна: управление никогда не будет передано на них, — и даже вредна: затрачиваемое время уходит впустую. Необходим критерий, определяющий целесообразность выполнения ДТ для некоторого региона памяти.
    
    \item В архитектурах, допускающих переменную длину инструкций, очень важен адрес, с которого начинается их декодирование, интерпретация или трансляция. Сдвиг даже на один байт приводит к изменению смысла до неузнаваемости (рис.~\ref{fig:byte-shift}). Кроме того, результат декодирования может зависеть от режима процессора, поэтому, если в ходе симуляции он изменился (например, процессор перешёл из 32-битного в 64-битный режим), то предыдущие блоки трансляции, скорее всего, перестали соответствовать исходному коду.
\end{itemize*}

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/byte-shift}
    \caption[Обнаружение кода]{Обнаружение кода. Смысл содержимого памяти меняется при изменении стартового адреса. Пример двух интерпретаций для фрагмента кода архитектуры IA-32}
    \label{fig:byte-shift}
\end{figure}

Указанные проблемы определяют задачу \textit{обнаружения кода} (\abbr code discovery). Точное её решение зависит от особеностей архитектур гостя и хозяина. Отметим лишь два ключевых момента.

\begin{itemize*}
    \item Некоторый регион в памяти разумно подвергать ДТ, если вероятность того, что он будет исполнен, ненулевая. Это верно в случае, когда он достижим из других, уже оттранслированных частей программ, т.е. известно, что некоторые инструкции передачи управления указывают на него. Если код исполнялся раньше, также велика вероятность того, что он исполнится в будущем.
    \item Очень важно кроме собственно содержимого блока трансляции хранить и все допустимые точки входа в него, т.е. адреса, попадающие на границы инструкций, а также ассоциировать режим процессора, для которого блок был создан.
\end{itemize*}

Отметим, что задача обнаружения кода при ДТ во многом связана с поддержкой самомодифицирующегося кода, описываемой в секции~\ref{sec:smc}.

\paragraph{Единицы трансляции.} Память хозяйской системы ограничена, что возвращает нас к первому вопросу — как выделять и организовывать блоки трансляций, чтобы  получить приемлемую скорость симуляции, при этом не исчерпав ёмкость хозяйского ОЗУ? Кроме того, необходимо определиться, какие блоки хранить, а какие выбрасывать, какую длину в байтах они должны иметь. Рассмотрим два возможных решения этих задач, которые основываются на принципе локальности исполнения и ограниченности рабочего набора~\citep{DBLP:books/daglib/0013597}.
 
\begin{enumerate*}
    
\item Трасса исполнения — это запись истории того, в каком порядке инструкции когда-то были исполнены. Как правило, трасса имеет ровно одну точку входа, соответствующую первой её инструкции. Из общих свойств алгоритмов следует высокая вероятность того, что впоследствии эти инструкции будут исполнены снова в том же порядке. При этом если они формируют базовый блок (т.е. среди них не встречается команд условного или непрямого перехода), то порядок их исполнения будет в точности такой же, как и в первый раз. Следует отметить, что первоначальное создание трасс, когда никакой истории исполнения ещё нет, приходится организовывать с помощью альтернативного механизма симуляции, например, интерпретацией (рис.~\ref{fig:bt-traces}). Прерывать создание трассы нужно по ряду условий в гостевом коде, после которых направление исполнения неизвестно или существенно отличается, например, на исключениях, прерываниях, командах смены режима процессора и т.п. %Длина трассы опрТипичная трасса содержит до десяти инструкций.

\begin{figure}[htbp]
    \centering
    \inputpicture{drawings/bt-traces}
    \caption[ДТ с трассами исполнения]{ДТ с трассами исполнения. Первое исполнение каждой гостевой инструкции производится с помощью интерпретатора, при этом также осуществляется её трансляция и сохранение результатата в трассе}
    \label{fig:bt-traces}
\end{figure}

\item Инструкции, располагающиеся в памяти по соседним адресам, скорее всего, относятся к связанным частям алгоритма программы, будут выполняться вместе и поэтому могут быть оттранслированы в один блок (рис.~\ref{fig:bt-pages}). В этом случае единицей трансляции является гостевая страница фиксированного размера. В отличие от трасс, страница трансляции может иметь множество точек входа — каждый адрес, соответствующий началу гостевой инструкции на ней, может быть использован таким образом. Однако необходимо следить, чтобы управление не передавалось «в середину» инструкции, иначе трансляция будет некорректной.

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/bt-pages}
    \caption[Двоичная трансляция целых страниц]{Двоичная трансляция целых страниц. Для ранее исполненных блоков переиспользуются оттранслированные секции хозяйского кода. Процесс симуляции прерывается для трансляции новой страницы}
    \label{fig:bt-pages}
\end{figure}

Кроме того, трансляция кода на текущей странице может быть прервана по достижении блока хозяйского кода определённого объёма. Как и в случае с трассами, разумно прерывать процесс ДТ при обнаружении инструкции условного или непрямого перехода. 

\end{enumerate*}

Хорошее описание приёмов ДТ, в ряде источников называемой \textit{JIT-компиляцией} (\abbr just in time), дано в \citep{TophamJones2007}.


% \subsection[Переходы между блоками трансляции]{Связи и переходы между блоками трансляции}\label{sec:linking}
% 
% \todo Картинка про блоки, входы выходы и вычисление адресов.

\section{Проблема самомодифицирующегося кода}\label{sec:smc}

Большая доля современных архитектур процессоров для компьютеров построена согласно принципам фон Неймана. Один из них состоит в том, что исполняемый код и обрабатываемые им данные располагаются в одной физической памяти. Следствие этого — возможность создания программ, которые в процессе работы изменяют код других программ и, в частности, свой собственный. Мы будем обобщённо обозначать такое явление, как \textit{самомодифицирующийся код} (\abbr self-modifying code, SMC). Для программ с SMC не все инструкции приложения известны до момента их генерации во время работы уже запущенного приложения.

Это обстоятельство фактически делает системы статической ДТ, не имеющие слой симуляции времени выполнения, функционально несостоятельными — они не могут корректно транслировать такой код.

\begin{digression}
Симулятор, задействующий динамическую двоичную трансляцию, сам по себе является программой с самомодифицирующимся кодом, так как на фазе симуляции управление передаётся на код, отсутствующий в исходном файле приложения, — он был создан «на лету» на фазе трансляции.
\end{digression}

При исполнении самомодифицирующейся программы гостевой код изменяется, и есть вероятность, что уже существующие блоки транслированного кода, соответствовавшие первоначальному состоянию памяти, перестанут подходить новому содержимому, и при передаче на них исполнения результат вычислений будет некорректен.  Для предупреждения этого необходимо отслеживать все записи в память и сбрасывать или ретранслировать затронутые при этом блоки. 

Поскольку процесс ДТ одного блока занимает существенное время, скорость работы симулятора для участков программ с самомодифицирующимся кодом  может резко падать — блоки живут недолго, часто отбрасываются как устаревшие, исполнение часто прерывается на ретрансляцию. В таких случаях простой интерпретатор может показывать более высокую скорость симуляции.

Следует иметь в виду, что детали поведения процессора при SMC могут отличаться на разных архитектурах. Обусловлено это тем, что в реальности инструкции берутся не непосредственно из памяти, а из более быстрых буферов, куда они были помещены специальными механизмами предварительной загрузки, и состояние памяти может не соответствовать их содержимому. Так, для систем с раздельными кэшами инструкций и данных (ARM, MIPS) результат модификации кода проявится только после выполнения  специальных инструкций сброса кэшей. В архитектуре Intel\textregistered IA-32 гарантируется, что результат SMC будет виден для исполняющего устройства немедленно. Исключением является изменение инструкции непосредственно под указателем инструкций — оно не будет видно программе, пока текущая инструкция не закончится.

В любом случае обеспечение работы SMC требует сброса части состояния и повторного считывания его из памяти, что вносит некоторую задержку в исполнение, и при неправильной организации кода его производительность может сильно пострадать.  

Ситуация усложняется, когда в моделируемой системе есть несколько агентов, способных модифицировать память, например, в многопроцессорных системах или в платформах, где устройства могут писать в память напрямую (\abbr direct memory access, DMA). В таких случаях модель должна отслеживать все такие доступы и отбрасывать устаревшие блоки.

\section{Оптимизирующая трансляция}\label{sec:optimisations}

После того, как некоторый блок трансляции создан, может оказаться, что возможно преобразовать его так, чтобы он исполнялся быстрее, при этом сохранив его семантику; другими словами, провести \emph{оптимизирующую} трансляцию. Этот процесс по смыслу аналогичен фазе оптимизаций обычного компилятора, позволяющей уменьшить время выполнения программ. Подчеркнём критически важное условие неизменности алгоритма фрагмента до и после преобразования. Если есть ненулевая вероятность того, что в каких-то случаях результат исполнения после применения определённой оптимизации будет отличаться от исходного, то её применять нельзя.

На рис.~\ref{fig:bt-optimization} приведён пример часто используемой оптимизации некоторого блока трансляции с одной точкой входа и выхода~\citep{helmstetter2011} для некоторой архитектуры. Гостевой код состоит из пяти арифметических инструкций \texttt{instr1} \dots \texttt{instr5} и инструкции \texttt{branch}. При трансляции капсулы отдельных инструкций\footnote{Несущественное для данного объяснения содержимое капсул объединено и обозначено угловыми скобками.} берутся последовательно друг за другом, формируя блок. При этом последняя машинная инструкция \texttt{inc} каждой из них предназначена для продвижения симулируемого регистра \texttt{PC}. 

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/bt-optimization}
    \caption[Оптимизация при ДТ]{Пример простой оптимизации кода блока трансляции. Инструкции \texttt{inc} продвижения регистра \texttt{PC} после каждой капсулы заменены одним сложением \texttt{add} в конце блока}
    \label{fig:bt-optimization}
\end{figure}

Оптимизация в данном случае основана на том факте, что значение этого регистра \texttt{PC} на протяжении почти всего блока никто не читает, и неважно, изменилось оно или нет. Поэтому можно отложить все изменения до того  момента, когда понадобится новое значение, т.е. до капсулы  инструкции перехода \texttt{<branch>}. Следующий напрашивающийся шаг — использовать очевидное равенство $x+1+1+1+1+1 = x +5$ и заменить пять инструкций сложения одной.

Как видно даже из столь простого примера, после оптимизациии границы между исходными капсулами размываются, т.к. составляющие инструкции могут быть переставлены местами, заменены другими или вообще убраны. 

Следующие типы оптимизаций, используемых в обычных компиляторах~\citep{dragonbook}, применимы и при двоичной трансляции.

\begin{description*}
\item[Удаление мёртвого кода] (\abbr dead code elimination) — нахождение команд, не влияющих на исполнение последующего кода. Вычисляемые ими значения не используются, поэтому и сами инструкции без вреда могут быть удалены.
\item[Удаление общих подвыражений] (\abbr common subexpression elimination) —  для вычислений, выполняемых более одного раза на рассматриваемом участке, второе и последующие их вхождения могут быть убраны и заменены уже вычисленным значением.
\item[Свёртка констант] (\abbr constant folding) и \textbf{дублирование констант} (\abbr constant propagation) — оптимизации для замены константных выражений и переменных на их значения, вычисленные при трансляции.
\item[Анализ соседних инструкций] (\abbr peephole optimization) — класс оптимизаций, основанных на знании особенностей хозяйской архитектуры и стоимости выполнения инструкций. Например, две подряд идущие команды могут быть заменены на одну более быструю.
\end{description*}

Как правило, блоки трансляции не включают в себя циклы. По этой причине такие оптимизации, как раскрытие, слияние, инверсия циклов (\abbr loop unrolling, loop fusion, loop inversion) и т.п., связанные с анализом потока управления, ограниченно доступны для задач симуляции. Примером такой оптимизации может считаться гиперсимуляция, описываемая в секции~\ref{sec:hypersim}.

\section{Вынесение фазы трансляции в отдельный поток}\label{sec:parallel-bt}

В описанном выше алгоритме динамической двоичной трансляции его фазы — трансляция и симуляция — чередуются, взаимно исключая исполнение друг друга. Однако осмысленным с точки зрения повышения производительности является вынесение процесса ДТ в отдельный хозяйский поток, исполняющийся параллельно с основным потоком, используемым для симуляции, и поставляющий для его нужд блоки трансляций~\citep{pqemu2001}.

Для сравнения на рис.~\ref{fig:serial-bt} и~\ref{fig:parallel-bt} приведено соотношение этапов исполнения и ожидания для этих двух активностей в случае последовательной ДТ и ДТ, вынесенный в отдельный поток.

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/serial-bt}
    \caption{ДТ и симуляция выполняются последовательно}
    \label{fig:serial-bt}
\end{figure}

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/parallel-bt}
    \caption{ДТ вынесена в отдельный поток}
    \label{fig:parallel-bt}
\end{figure}

Очевидно, что выигрыш в производительности у такого решения будет наблюдаться, только если поток трансляции будет успевать генерировать новые блоки раньше, чем они понадобятся потоку симуляции. В противном случае последний всё равно будет вынужден простаивать. При этом структура симулятора значительно усложняется, так как необходимо производить координацию и синхронизацию двух потоков, не допуская использования блоков до того, как они будут полностью готовы, и следя за тем, чтобы поток ДТ работал с самой актуальной версией гостевого кода. Можно пойти ещё дальше и не ограничиваться единственным потоком трансляции — их может быть несколько, и все они будут снабжать один поток симуляции свежими блоками.

\section{Прямое исполнение}\label{sec:dex}

Важным на практике случаем ДТ является ситуация, когда архитектуры гостя и хозяина совпадают (или почти совпадают). При этом возникает возможность значительно упростить трансляцию — в некоторых случаях она сводится к копированию гостевого кода как хозяйского или даже исполнению его «на месте», без дублирования. Подобные режимы симулирования имеют общее название \textit{прямое исполнение} (\abbr direct execution, DEX).

Несмотря на кажущуюся простоту реализации, необходимо отметить особенности, усложняющие схемы DEX. Как и для других ранее рассмотренных режимов, изолирование выполнения кода гостевых приложений и кода самого симулятора является критически важным свойством. Гостевое приложение не должно иметь возможность определить факт того, что оно исполняется внутри модели, и тем более влиять на работу симулятора. Приведём некоторые примеры операций, которые нарушают это условие при прямом исполнении.

\begin{itemize*}

\item \textit{Доступы к памяти и периферии.} Адресное пространство гостя занимает часть памяти симулятора и не обязательно размещено по тем же самым абсолютным адресам, где гостевое приложение ожидает его увидеть. ДТ поэтому должен перехватывать все доступы в память и «переписывать» их так, чтобы они всегда указывали на корректные данные и не могли повредить память самой модели. Аналогично, гостевое приложение не должно иметь прямого доступа к периферийным устройствам хозяина.

\item \textit{Архитектурное состояние.} Регистровый файл гостя и хозяина совпадает, поэтому невозможно полностью разместить гостевые регистры на одноимённых хозяйских — некоторое их количество зарезервировано для нужд самого симулятора. Опять же, гость не должен получать доступ к состоянию регистров, задействованных моделью, — необходимо перехватывать обращения к ним и подставлять правильные значения. Как правило, регистровый файл используется в двух переключаемых режимах: во время исполнения транслированного кода большая его часть заполнена состоянием гостя, а при выходе в симулятор оно сбрасывается в память, и регистры используются для нужд симулятора. По возвращении в транслированный код состояние восстанавливается.

\item\textit{Привилегированные инструкции.} Будучи пользовательским приложением, симулятор работает в непривилегированном режиме, тогда как гостевое приложение может исполнять инструкции системных режимов. Без явного контроля со стороны ДТ это, скорее всего, приведёт к аварийному завершению процессов. Поэтому симулятор должен заранее находить в потоке команд гостя «опасные» инструкции и заменять собственными обработчиками. Альтернативно, иногда имеется аппаратно поддерживаемая возможность перехватить исключение от попытки исполнения привилегированной инструкции, промоделировать её в обработчике исключения и вернуться к исполнению. Интересные особенности при этом существуют в архитектуре IA-32 — семантика некоторых инструкций меняется в зависимости от того, в каком режиме процессора они исполняются. Пример — \texttt{POPF} (\abbr pop flag register), которая модифицирует флаг Interrupt Enable, будучи исполнена в привилегированном режиме; в пользовательском режиме она может изменить все флаги, кроме вышеуказанного.

\end{itemize*}

\subsection[Предпросмотр кода]{Предпросмотр кода. Использование заглушек и~заплаток}

Каким образом возможно обойти эти ограничения? Прежде чем передавать управление в гостевую программу, необходимо убедиться, что это безопасно. 

\textit{Предпросмотр} (\abbr lookahead) — процесс инспектирования гостевого кода на предмет инструкций, запрещённых к прямому исполнению и/или требующих выполнения дополнительных действий, связанных с работой симулятора.

В результате предпросмотра найденные проблемные инструкции необходимо каким-то образом «обезвредить». Рассмотрим два способа, как это можно сделать.

\begin{description*}
\item[Заплатка (\abbr patch)] — фрагмент машинного кода, заменяющий одну исходную инструкцию. Например, гостевые инструкции для доступов в память изначально указывают на гостевую память, которая при симуляции может быть размещена по совершенно другим адресам. Таблица соответствия гостевых и хозяйских адресов доступна симулятору. В результате наложения заплатки адреса будет переписаны таким образом, чтобы указывать в моделируемую память (рис.~\ref{fig:patching}).

\item[Заглушка (\abbr stub)] — приём, в котором исходная инструкция заменяется на другую, вызывающую (с помощью инструкции безусловного перехода или ловушки) процедуру, подготовленную симулятором (рис.~\ref{fig:stubbing}). В отличие от метода с использованием заплатки, длина такой процедуры неограничена и поэтому она может содержать достаточно сложную логику. После её завершения управление передаётся обратно в гостевой код.
\end{description*}

\begin{figure}[htpb]
    \centering
    \inputpicture{drawings/patching}
    \caption[Использование заплаток]{Использование заплаток. После применения техники все адреса обращений к памяти заменены ссылками на симулируемые}
    \label{fig:patching}
\end{figure}

\begin{figure}[htpb]
    \centering
    \inputpicture{drawings/stubbing}
    \caption[Использование заглушек]{Использование заглушек. Инструкции, требующие контролируемого выполнения, заменяются на инструкции безусловной передачи управления в процедуру-обработчик симулятора}
    \label{fig:stubbing}
\end{figure}

\paragraph{Сложности.} Существует множество других ситуаций в работе DEX, возможность возникновения которых необходимо учитывать, чтобы удержать гостевое приложение под контролем симулятора.

\begin{itemize*}
    \item Переменная длина инструкций может привести к тому, что затруднительно будет накладывать заплатки и заглушки, при этом не повредив код, следующий за проблемной гостевой инструкцией, так как их длина может оказаться больше, чем у заменяемой инструкции.
    \item   От симулятора требуется следить за тем, какие места в исходном коде были изменены в результате применения заплаток и заглушек, и не позволять гостевому приложению обнаружить или переписать эти изменения, например, при SMC.
   \item Необходимо предусмотреть установку собственных обработчиков исключений, которые может породить гостевой код, для того, чтобы предотвратить возможность аварийного завершения симулятора. 
   \item Если гость пытается начать исполнять код, которые ещё не был просмотрен и не был помечен как безопасный, управление должно быть передано симулятору.
   \item Значение гостевых адресов не всегда может быть известно на этапе предпросмотра кода. Из-за этого не всегда возможно определить, какие симулируемые адреса им соответствуют. Это приводит к тому, что невозможно использовать заплатки для подмены адресов.
\end{itemize*}

\begin{digression}
Можно рассматривать техники ДТ как экстремальный случай использования заплаток и заглушек, в котором \emph{каждая} инструкция заменяется капсулой — фрагментом контролируемого симулятором кода. С другой стороны, DEX — вариант ДТ, в котором капсулы большого числа инструкций имеют размер в одну инструкцию.
\end{digression}

\subsection{Инструментация}

Более общий подход, при котором двоичный код, прежде чем быть исполненным, подвергается модификациям, имеет название \textit{инструментация}. Она используется в общем случае для построения произвольных инструментов анализа приложений, не только для симуляции, и выступает как легковесная альтернатива последней для случаев, когда гостевая и хозяйская архитектуры совпадают.

В качестве примера комплекса динамической двоичной инструментации рассмотрим проект Pin~\citep{pin} — открытый проект для анализа программ архитектуры Intel IA-32. Для проведения анализа пользователь пишет и компилирует pintool — библиотеку на C++, использующую предоставляемый API. В этой библиотеке описываются действия, выполняемые на границах отдельных инструкций, базовых блоках или трасс исполнения изучаемой программы, которая запускается под управлением Pin. Предоставляются возможности для анализа и записи хода исполнения приложения, например, сбор статистики, поиск утечек памяти, обеспечение детерминистичного повторения исполнения параллельных программ, симуляции системы кэшей и т.д. Кроме того, возможно модифицировать семантику отдельных инструкций произвольным образом.  Известно несколько симуляторов для вариантов архитектуры IA-32, построенных на основе Pin~\citep{intel-sde, graphite2010, cmpsim, carlson2011etloafsaapms}.

\subsection[Виртуализационные расширения]{Виртуализационные расширения архитектуры и их использование для~прямой симуляции}

Сценарий симуляции с совпадающей архитектурой гостя и хозяина является часто используемым на практике. Использование DEX при этом позволяет (теоретически) достичь максимальной скорости за счёт минимизации накладных расходов на симуляцию. Однако необходимость предпросмотра и модификации гостевого кода значительно усложняет разработку симулятора и/или  ограничивает спектр приложений, которые будут при этом корректно работать, а также негативно влияет на скорость. Многочисленность инструкций, требующих перехвата, а также особенности гостевой архитектуры могут привести к тому, что написание модели с DEX окажется едва ли не сложнее аналогичного «честного» двоичного транслятора.

В ряде архитектур существует аппаратная поддержка DEX, позволяющая избавиться от необходимости предпросмотра и модификаций кода и тем самым значительно уменьшить накладные расходы на часто используемые при симуляции операции. Например, «дорогая» операция трансляции адресов гостя в реальные адреса хозяина может быть поддержана аппаратно с помощью дополнительного уровня косвенности в механизме обращения к страницам.

\paragraph{Примеры.} IBM System/370 была спроектирована таким образом, что позволяла исполнять напрямую копии операционной системы в изолированных контейнерах. В случае, когда при этом встречалась привилегированная инструкция, она обрабатывалась симулятором (в терминологии System/370 — Control Program, CP) прозрачно для приложения. Следует отметить, что в современном варианте данной архитектуры, именуемой System z, данная функциональность также присутствует.

Архитектура IA-32 довольно долгое время не имела эффективного механизма аппаратной поддержки прямого исполнения изолированных окружений. Она была добавлена в форме расширения Intel\textregistered VTx в 2005 г. Аналогичный набор команд был представлен компанией AMD и получил название AMD SVM.

\paragraph{Монитор.} После входа в изолированный режим гость имеет возможность исполнять любые инструкции, в том числе привилегированные, и проводить обращения к периферийным устройствам. 
В режим \textit{монитора виртуальных машин} процессор попадает, когда работа исполняемого гостя требует вмешательства симулятора (рис.~\ref{fig:vm-assist}). При этом ему доступно всё архитектурное состояние, которое можно инспектировать и модифицировать. Затем процессор может передать управление обратно в «непривилегированный» режим исполняемой виртуальной машины; переключение состояния будет произведено автоматически.

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/vm-assist}
    \caption[Аппаратная поддержка переключения контекста между монитором виртуальных машин и гостевой системой]{Аппаратная поддержка переключения контекста между монитором виртуальных машин и гостевой системой. При входе в режим виртуальной машины с помощью системной инструкции контекст хозяина сохраняется в выделенной области памяти и заменяется контекстом гостя. При любой причине обратного перехода в режим монитора (например, при попытке выполнить зарезервированную операцию) этот контекст обменивается с гостевым}
    \label{fig:vm-assist}
\end{figure}

Таким образом, пропадает необходимость в предпросмотре кода гостя. Все связанные с этим процессом сложности и потери производительности исчезают. Кроме того, это позволяет ускорить обработку таких дорогих с точки зрения симуляции операций гостевых систем, как преобразование виртуальных адресов в физические~\citep{ulrich-virt-cost}. Они проводятся аппаратурой, что упрощает (и делает более надёжной) реализацию монитора.  Более подробно вопросы аппаратной поддержки виртуализации разбираются в главе~\ref{virt}.

\section{Гиперсимуляция}\label{sec:hypersim}

\dictum[Kevin Flynn, «TRON: Legacy»]{It's amazing how productive doing nothing can be\footnotemark.}
\footnotetext{Удивительно, насколько продуктивным может быть бездействие.}


Как было показано выше, выигрыш в скорости от использования технологий ДТ обусловлен переиспользованием однажды сгенерированного хозяйского кода для многих последующих циклов симуляции; этот выигрыш теряется при несоблюдении условий постоянства машинного кода, как было показано в секции про SMC. 

Заметим, что, несмотря на то, что при благоприятных для ДТ условиях блок оттранслированного кода неизменен, при различных входах в симуляцию с одного и того же указателя гостевых инструкций архитектурное состояние и содержимое памяти могут различаться. 

Рассмотрим случаи, когда архитектурное состояние при всех входах в некоторый блок кода остаётся неизменным. Исходя из свойства детерминистичности вычислительных систем, можно утверждать, что по выходу из такого блока состояние системы каждый раз будет одно и то же. Очевидно, что для таких участков кода нет нужды каждый раз их симулировать — достаточно один раз запомнить результат вычисления и просто изменять состояние системы после входа в блок на конечное, таким образом полностью избегая вычислений и достигая «бесконечно высокой» скорости симуляции (рис.~\ref{fig:hypersim}). Данный «режим» имеет название \textit{гиперсимуляция} (\abbr hypersimulation).

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/hypersim}
    \caption[Гиперсимуляция]{Гиперсимуляция. При обнаружении возможности симулируемое время продвигается вперёд до следующего события, состояние процессора при этом неизменно}
    \label{fig:hypersim}
\end{figure}

Упомянутые выше условия, позволяющие применить данную оптимизацию и налагаемые на код, очень жестки. На практике они выполняются только для очень небольших блоков кода, например, в реализациях примитива синхронизации «циклическая блокировка» (\abbr spin lock). Типичная реализация для IA-32, написанная на ассемблере, выглядит следующим образом:

\begin{lstlisting}
spin_lock:
movl $1, %eax
lock xchgl (locked), %eax
testl %eax, %eax
jnz spin_lock
\end{lstlisting}

В примере процессор непрерывно атомарно записывает в переменную \texttt{locked} до тех пор, пока она не станет равной нулю. Изменить её может другой процессор, разделяющий память с первым (о симуляции многопроцессорных систем см. главу~\ref{fullplatform}), например, следующим образом:

\begin{lstlisting}
spin_unlock:
movl $0, %eax
xchgl (locked), %eax
\end{lstlisting}

При последовательной симуляции этих двух гостевых процессоров на одном хозяйском (т.е. на симуляцию каждого отведена квота времени, в течение которой состояние неактивного процессора не изменяется) значение \texttt{locked} не меняется в процессе симуляции первого. Поэтому вместо того, чтобы тратить время на моделирование этого «бесконечного» цикла, следует скачком переместить симулируемое время первого процессора до конца его квоты, не изменив при этом его архитектурное состояние. Затем передать управление второму процессору, который выполнит необходимую разблокировку.

\paragraph{Нахождение шаблонов гиперсимуляции.} Для того, чтобы использовать гиперсимуляцию, симулятор должен уметь детектировать ситуации, в которых она применима. Такая функциональность может быть реализована двумя способами.

\paragraph{Задавать шаблоны вручную.} В этом случае машинный код цикла — \emph{шаблон гиперсимуляции} — формируется пользователем и передаётся симулятору, который при работе проверяет, соответствует ли ему гостевой год. Если найдено совпадение, то применяется гиперсимуляция. Для этого подхода характерны следующие особенности.

\begin{itemize*}
    \item Пользователь должен выполнить работу по анализу своего сценария симуляции, идентифицировать в нём места, которые выиграют в производительности от гиперсимуляции, и сформулировать для них шаблоны. Как правило, эта работа выполняется, если обнаружено, что для конкретного сценария наблюдаются проблемы с производительностью. 
    \item Для каждого сценария шаблоны могут быть свои. Например, каждая операционная система может реализовывать атомарные примитивы собственным образом.
    \item Симулятор не может проверить, действительно ли переданные ему шаблоны корректны, т.е. что симуляция с их использованием не приведёт к некорректному изменению состояния гостевой системы. Вся ответственность при этом ложится на человека.
\end{itemize*}

\paragraph{Автоматическое детектирование кода, допускающего гиперсимуляцию.} Чтобы избавить человека от кропотливой работы по выявлению шаблонов, разумно попытаться переложить её на сам симулятор. Для этого он должен уметь анализировать циклы в гостевом коде и обнаруживать среди них те, для которых допустимо пропустить часть итераций. Для двоичного транслятора это может делаться в одной из стадий оптимизаций результатов трансляции, когда известны связи между отдельными блоками. Рассмотрим плюсы и минусы этого подхода.

\begin{itemize*}
    \item Самое очевидное преимущество — это избавление от необходимости делать ручную работу по выявлению шаблонов для каждого сценария симуляции.
    \item Программа зачастую способна выявить связи между блоками лучше, чем это смог бы человек, и таким образом обнаружить больше шаблонов для оптимизации, обладающих сложными условиями применения.
    \item С другой стороны, автоматическое детектирование, не обладающее полным представлением о специфике сценария симуляции, должно действовать консервативно. Это приводит к тому, что шаблоны для некоторых классов алгоритмов не будут построены. Например, если внутри цикла происходит чтение или запись в устройство, то он не может быть автоматически гиперсимулирован, т.к. неизвестны побочные эффекты от таких обращений.
\end{itemize*}

\section[Динамическое  переключение режимов симуляции]{Динамическое  переключение режимов симуляции на различных участках работы системы}

Все продемонстрированные выше техники симуляции — интерпретация, двоичная трансляция, прямое исполнение, аппаратно ускоренная симуляция, гиперсимуляция —  характеризуются условиями, в которых их применение оправдано, т.е. они дают выигрыш в скорости, и ситуациями, когда использование невыгодно. Поэтому на практике часто применяется комбинированное использование двух или более техник с переключением между ними на различных этапах симуляции, при этом выбирается наиболее быстрая из доступных.

Рассмотрим гипотетический пример: моделирование загрузки операционной системы на архитектуре IA-32 с последующим запуском пользовательского приложения. На нём разберём, в какие моменты оптимальны различные техники симуляции.
 
\begin{itemize*}
\item На первых секундах работы во время исполнения системной прошивки (BIOS или UEFI firmware) процессор использует новый способ адресации данных, недоступный в аппаратуре хозяина. Для симуляции используется двоичная трансляция, так как прямое исполнение невозможно.

%В первые секунды работы, когда активна программа BIOS, процессор IA-32 находится в реальном режиме\footnote{Этот режим характеризуется 16-битной шириной регистров и адресов памяти с выключенными механизмами сегментации и страничного преобразования.}. При этом используется двоичная трансляция.

\item Затем начинает загружаться операционная система. Режим процессора меняется на защищённый, и аппаратная поддержка прямого исполнения, недоступная ранее, может быть задействована. Используется прямое исполнение. Если в процессе работы ОС случаются обращения к сервисам системной прошивки, то для них симуляция возвращается к ДТ.

\item Запускается пользовательское приложение, активно модифицирующее свой код. В таких условиях все «оптимизирующие» режимы теряют свои преимущества, и потому исполнение происходит с помощью интерпретации.

\item В процессе работы параллельного гостевого приложения один из потоков делает циклическую блокировку, ожидая готовности данных от другого потока. Симулятор детектирует ситуацию ожидания и выполняет ожидающий поток с помощью гиперсимуляции.

\end{itemize*}

Необходимо иметь эффективный алгоритм принятия решения о переключении между режимами симуляции. Универсального решения этой задачи нет. Как правило, решение использует некоторые эвристики, выработанные для конкретного применения симулятора. Перечислим наиболее частые подходы к динамическому определению оптимального режима (рис.~\ref{fig:gearbox}).

\begin{itemize*}
\item Собирается статистика частоты нахождения в различных блоках гостевого кода. Если обнаруживается, что в каком-то блоке программа проводит много времени, то для него включается ДТ. Для остальных блоков продолжается использоваться интерпретация.

\item Программой измеряется скорость собственной работы в оптимизированных режимах. Если обнаруживается, что она ниже некоторого порога, то происходит  возвращение к интерпретации; при этом экономится время, ранее тратившееся на неэффективную ДТ.

\item Анализируется статистика частот событий, мешающих оптимизированным режимам эффективно работать. Для ДТ это случаи необходимости ретрансляции блоков, для аппаратно поддерживаемого прямого исполнения это события возвращения в программу-монитор. Если такие события происходят чаще некоторого порога, то соответствующий режим отключается.
\end{itemize*}


\begin{figure}[htb]
    \centering
    \inputpicture{drawings/gearbox}
    \caption[Динамическое переключение режимов симуляции]{Динамическое переключение режимов симуляции}
    \label{fig:gearbox}
\end{figure}


\section[Пример практической двоичной трансляции]{Пример практической двоичной трансляции}

Для иллюстрации того, насколько видоизменяется машинный код при трансляции, рассмотрим реальный пример работы Wind River\textregistered~Simics. При работе ДТ производится несколько стадий преобразования промежуточного представления в конечный код, включая стадии распределения регистров и оптимизации полученного кода. Ниже приведены 16 исходных гостевых инструкций процессора IA-32, а также результат их преобразования — 532 хозяйские инструкции для этой же архитектуры.

\subsection{Исходный блок инструкций}

\begin{lstlisting}
simics> viper.mb.cpu0.core[0][0].disassemble-block %rip
Block 0x111cb .. 0x111fd matched. Compiled at 5176663075. Use count 1.
532 host instructions / 16 target instructions (= 33.3).

v:0x000111cb p:0x000111cb mov eax,ebx
v:0x000111cd p:0x000111cd mov ecx,ebx
v:0x000111cf p:0x000111cf cdq
v:0x000111d0 p:0x000111d0 idiv dword ptr -28[ebp]
v:0x000111d3 p:0x000111d3 mov eax,dword ptr -28[ebp]
v:0x000111d6 p:0x000111d6 sub ecx,edx
v:0x000111d8 p:0x000111d8 sub eax,edx
v:0x000111da p:0x000111da mov dword ptr -40[ebp],ecx
v:0x000111dd p:0x000111dd mov cl,byte ptr -32[ebp]
v:0x000111e0 p:0x000111e0 mov dword ptr -36[ebp],eax
v:0x000111e3 p:0x000111e3 mov eax,dword ptr -40[ebp]
v:0x000111e6 p:0x000111e6 shl edx,cl
v:0x000111e8 p:0x000111e8 cmp eax,dword ptr [0x30e68]
v:0x000111ee p:0x000111ee lea edx,0x70000[esi][edx]
v:0x000111f5 p:0x000111f5 mov dword ptr -44[ebp],edx
v:0x000111f8 p:0x000111f8 je 0x11332
\end{lstlisting}

\subsection{Результат трансляции}

\begin{lstlisting}
0x155d69a0  sub dword ptr [cpu + turbo_event_counter],0x10
0x155d69a7  jle 0x155d7157
0x155d69ad  mov eax,dword ptr [cpu + RBX]
0x155d69b3  mov ebp,eax
0x155d69b5  mov dword ptr [cpu + RAX],ebp
0x155d69bb  mov dword ptr [cpu + hi32(RAX)],0x0
0x155d69c5  mov dword ptr 4[esp],eax
0x155d69c9  mov dword ptr [cpu + RCX],eax
0x155d69cf  mov dword ptr [cpu + hi32(RCX)],0x0
0x155d69d9  mov dword ptr 8[esp],ebp
0x155d69dd  mov edi,ebp
0x155d69df  shr edi,31
0x155d69e2  test edi,edi
0x155d69e4  je 0x155d7134
0x155d69ea  mov edi,0xffffffff
0x155d69ef  mov dword ptr 12[esp],edi
0x155d69f3  mov dword ptr [cpu + RDX],0xffffffff
0x155d69fd  mov dword ptr [cpu + hi32(RDX)],0x0
0x155d6a07  mov ecx,dword ptr [cpu + RBP]
0x155d6a0d  mov dword ptr 16[esp],ecx
0x155d6a11  mov edx,ecx
0x155d6a13  add edx,0xffffffe4
0x155d6a16  mov ebx,dword ptr 20[esp]
0x155d6a1a  xor ebx,ebx
0x155d6a1c  mov eax,dword ptr [cpu + ss_base]
0x155d6a22  mov ecx,dword ptr [cpu + hi32(ss_base)]
0x155d6a28  mov edi,edx
0x155d6a2a  mov ebp,ebx
0x155d6a2c  add edi,eax
0x155d6a2e  adc ebp,ecx
0x155d6a30  mov eax,edi
0x155d6a32  shr eax,8
0x155d6a35  and eax,0x3ff0
0x155d6a3b  add eax,dword ptr [cpu + stc_load_current_mode]
0x155d6a41  cmp ebp,dword ptr 4[eax]
0x155d6a44  jne 0x155d711c
0x155d6a4a  mov ebp,dword ptr [eax]
0x155d6a4c  xor ebp,edi
0x155d6a4e  and ebp,0xfffff003
0x155d6a54  jne 0x155d711c
0x155d6a5a  mov ebp,dword ptr 8[eax]
0x155d6a5d  mov ebp,dword ptr 0[ebp][edi]
0x155d6a61  mov edi,dword ptr 24[esp]
0x155d6a65  xor edi,edi
0x155d6a67  mov ebx,ebp
0x155d6a69  test ebp,ebp
0x155d6a6b  jne 0x155d6a83
0x155d6a6d  test edi,edi
0x155d6a6f  jne 0x155d6a7d
0x155d6a71  add dword ptr [cpu + turbo_event_counter],0xc
0x155d6a78  call turbo_raise_exception
0x155d6a7d  mov ebp,dword ptr 28[esp]
0x155d6a81  jmp 0x155d6a87(unknown call target)
0x155d6a83  mov ebp,dword ptr 28[esp]
0x155d6a87  xor ebp,ebp
0x155d6a89  mov edi,dword ptr 32[esp]
0x155d6a8d  xor edi,edi
0x155d6a8f  mov dword ptr 32[esp],edi
0x155d6a93  mov edi,dword ptr 8[esp]
0x155d6a97  or ebp,edi
0x155d6a99  mov dword ptr 28[esp],ebp
0x155d6a9d  mov ebp,dword ptr 32[esp]
0x155d6aa1  mov edi,dword ptr 12[esp]
0x155d6aa5  or edi,ebp
0x155d6aa7  mov eax,ebx
0x155d6aa9  cdq
0x155d6aaa  push edx
0x155d6aab  push eax
0x155d6aac  push edi
0x155d6aad  mov ebp,dword ptr 40[esp]
0x155d6ab1  push ebp
0x155d6ab2  call turbo_sdiv64
0x155d6ab7  add esp,0x10
0x155d6aba  mov ecx,edx
0x155d6abc  mov ebp,eax
0x155d6abe  test edx,edx
0x155d6ac0  jl 0x155d6ad8
0x155d6ac2  jg 0x155d6acc
0x155d6ac4  cmp eax,0x7fffffff
0x155d6aca  jbe 0x155d6ad8

<... Пропущено ...>

0x155d7045  mov al,byte ptr [cpu + pc_flags.zf]
0x155d704b  movzx eax, al
0x155d704e  jmp 0x155d7012(unknown call target)
0x155d7050  push 2
0x155d7055  push ebp
0x155d7056  push ecx
0x155d7057  mov ebp,dword ptr 124[esp]
0x155d705b  push ebp
0x155d705c  mov ebp,dword ptr 124[esp]
0x155d7060  push ebp
0x155d7061  call turbo_stc_miss_store_uint32_le
0x155d7066  add esp,0x14
0x155d7069  mov ebp,dword ptr 104[esp]
0x155d706d  jmp 0x155d6fe4(unknown call target)
0x155d7072  push 4
0x155d7077  push 0
0x155d707c  push 200296
0x155d7081  call turbo_stc_miss_load_uint32_le
0x155d7086  add esp,0xc
0x155d7089  mov edi,eax
0x155d708b  mov edx,dword ptr 12[esp]
0x155d708f  jmp 0x155d6f1c(unknown call target)
0x155d7094  push 6
0x155d7099  push eax
0x155d709a  push ebp
0x155d709b  call turbo_stc_miss_load_uint32_le
0x155d70a0  add esp,0xc
0x155d70a3  mov ebp,eax
0x155d70a5  jmp 0x155d6d94(unknown call target)
0x155d70aa  push 7
0x155d70af  push edx
0x155d70b0  push edi
0x155d70b1  mov ebp,dword ptr 72[esp]
0x155d70b5  push ebp
0x155d70b6  mov ebp,dword ptr 24[esp]
0x155d70ba  push ebp
0x155d70bb  call turbo_stc_miss_store_uint32_le
0x155d70c0  add esp,0x14
0x155d70c3  mov edi,dword ptr 16[esp]
0x155d70c7  jmp 0x155d6d44(unknown call target)
0x155d70cc  push 8
0x155d70d1  push ecx
0x155d70d2  push ebp
0x155d70d3  call turbo_stc_miss_load_uint8
0x155d70d8  add esp,0xc
0x155d70db  mov ecx,dword ptr 4[esp]
0x155d70df  jmp 0x155d6cc8(unknown call target)
0x155d70e4  push 9
0x155d70e9  push ecx
0x155d70ea  push edi
0x155d70eb  mov ebp,dword ptr 56[esp]
0x155d70ef  push ebp
0x155d70f0  mov ebp,dword ptr 64[esp]
0x155d70f4  push ebp
0x155d70f5  call turbo_stc_miss_store_uint32_le
0x155d70fa  add esp,0x14
0x155d70fd  mov edi,dword ptr 16[esp]
0x155d7101  jmp 0x155d6c73(unknown call target)
0x155d7106  push 12
0x155d710b  push ecx
0x155d710c  push edi
0x155d710d  call turbo_stc_miss_load_uint32_le
0x155d7112  add esp,0xc
0x155d7115  mov ebp,eax
0x155d7117  jmp 0x155d6b9f(unknown call target)
0x155d711c  push 13
0x155d7121  push ebx
0x155d7122  push edx
0x155d7123  call turbo_stc_miss_load_uint32_le
0x155d7128  add esp,0xc
0x155d712b  mov ebp,eax
0x155d712d  mov edi,edx
0x155d712f  jmp 0x155d6a67(unknown call target)
0x155d7134  mov edi,dword ptr 12[esp]
0x155d7138  xor edi,edi
0x155d713a  mov dword ptr 12[esp],edi
0x155d713e  mov dword ptr [cpu + RDX],0x0
0x155d7148  mov dword ptr [cpu + hi32(RDX)],0x0
0x155d7152  jmp 0x155d6a07(unknown call target)
0x155d7157  mov dword ptr [cpu + turbo_exit_reason_and_offset],0x1001cb01
0x155d7161  ret
532 instructions, 1986 bytes, 0 spill instructions 0.00%, 65 copy instructions 12.22%
\end{lstlisting}

\input{bt-questions}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

