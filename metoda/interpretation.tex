% Copyright (c) 2016 Grigory Rechistov <grigory.rechistov@gmail.com>
% This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Worldwide.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/.

\chapter{Модели процессора на основе интерпретации}\label{interpretation}

\dictum[Nick Morgan]{Assembly language is the lowest level of abstraction in computers — the point at which the code is still readable\footnotemark}
\footnotetext{Язык ассемблера — самый низкий уровень абстракции в компьютерах, точка, в которой код программ всё ещё можно разобрать.}

%\dictum[Уильям Томсон (лорд Кельвин)]{Понять — значит построить модель.}

<<Интерпретатор>> в общем значении слова — тот, кто занимается переводом текста с одного языка на другой. В контексте вычислительной техники этот термин противопоставляется трансляторам и компиляторам; последние два понятия описывают программы, преобразующие тексты на входном языке (машинном или высокого уровня) в новое представление, оперируя при этом достаточно большими его блоками — файлами, модулями, функциями и т.п. Интерпретатор же ограничивается работой над одной <<строкой>> (например, машинной инструкцией) входного языка. Следующая строка будет преобразована (\emph{проинтерпретирована}) тогда, когда в этом возникнет необходимость.

\section{Архитектурное состояние}

Прежде чем перейти к описанию алгоритмов, опишем структуру системы, модель которой будет построена. Кроме того, определим, какие структуры данных используются для представления состояния процессора в простой функциональной модели\footnote{Подробнее о моделировании архитектурного состояния рассказывается в главе~\ref{state}.}.

Практически никогда центральный процессор не работает в изоляции. Как минимум, ему требуется откуда-то брать машинный код и где-то хранить данные, используемые текущей программой. Поэтому минимальная система будет включать ЦПУ и оперативную память, а также канал двусторонней связи между ними (рис.~\ref{fig:cpu-mem}).

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/cpu-mem}
    \caption{Простая система, состоящая из процессора (CPU) и памяти (RAM)}
    \label{fig:cpu-mem}
\end{figure}

Мы будем расширять набор устройств в этой системе в последующих главах.

В любом классическом процессорном устройстве всегда присутствует регистр, хранящий адрес текущей исполняемой инструкции. Например, в архитектуре IA-32~\citep{intelmanual2a} для этого используется семейство xIP: \texttt{IP}, \texttt{EIP}, \texttt{RIP}, в архитектуре ARM~\citep{arm-sdg} он имеет название \texttt{pc}, в других системах он может называться по-другому, например, \texttt{IC} (\abbr instruction counter). В дальнейшем для единообразия мы будем использовать обозначение \texttt{PC} (\abbr program counter).

Кроме указателя инструкций, процессоры содержат множество других регистров, типы, назначение и параметры которых зависят от модели. В большинстве случаев присутствуют регистры общего назначения (\abbr general purpose registers, GPR), используемые в арифметических операциях и при адресации памяти.

В языке Си (и С++) описание состояния может быть представлено структурой \texttt{state_t}, содержащей поля для всех регистров, а также ссылки на внешние устройства:

\begin{lstlisting}
typedef uint32_t register_t; // ширина гостевых регистров
const int n_regs = 16; // число регистров
typedef struct {
    register_t pc; // счётчик инструкций
    register_t gpr[n_regs]; // регистры общего назначения
    uint8_t *memory; // указатель на ОЗУ
} state_t;
\end{lstlisting}

Заметим, что данное описание очень далеко от того, чтобы быть полным, однако оно даёт базовое представление того, с чем приходится иметь дело в начале разработки новой модели.

\section{Стадии работы интерпретатора}
Алгоритм работы в общих чертах напоминает стадии конвейера исполнения команд в настоящем процессоре\footnote{Отметим, что число стадий может быть различно. У разных моделей оно варьируется от одной до двадцати и более.} (рис.~\ref{fig:interp-cycle-expanded}).

\begin{figure}[htb]
    \centering
	\inputpicture{drawings/interp-cycle-expanded}
    \caption{Рабочий цикл интерпретатора}
    \label{fig:interp-cycle-expanded}
\end{figure}

\begin{enumerate*}

\item Извлечение (\abbr fetch) кода инструкции из памяти по адресу, вычисляемому из значения \texttt{PC}. Конкретная формула зависит от деталей архитектуры и текущего режима процессора.

В модели это действие идентично операции чтения из памяти и может вызывать соответствующие побочные эффекты.

\item Задача декодирования (\abbr decode) состоит в том, чтобы по числу, полученному в предыдущей фазе, определить, какую операцию следует выполнить и какие аргументы в ней будут участвовать.

Алгоритм и сложность декодирования сильно зависят от сложности самого языка инструкций целевой машины. Как правило, процесс состоит из поиска и сопоставления битовых полей считанного машинного слова  со значениями из заранее созданных таблиц. В силу многих факторов (например, переменной длины инструкций, различного смысла значений в различных режимах процессора, использования префиксов и т.п.) оно может занимать существенную часть времени работы интерпретатора. Мы рассмотрим декодирование подробнее в секции~\ref{sec:decoding}.

\item Исполнение (\abbr execute) состоит из непосредственной симуляции функции только что декодированной инструкции. Как правило, это вычисление результата арифметической или логической операции, изменение режима модели процессора или передача контроля управления в другую секцию алгоритма.

Каждому коду машинной операции (\textit{опкоду}) в модели должна соответствовать одна моделирующая процедура (\abbr service routine). В самой простой схеме интерпретатора выбор процедуры по опкоду производится с помощью конструкции множественного выбора — переключателя — используемого языка программирования. В языке Си это оператор \texttt{switch}, поэтому данная схема имеет название \textit{переключаемая} (\abbr switched):

\begin{lstlisting}
switch (opcode) {
    case OPERATION1: ... // процедура 1
    case OPERATION2: ... // процедура 2
    ...
    default: ... // неизвестная инструкция
}
\end{lstlisting}


\item Запись результата (\abbr write back) операции в архитектурные регистры. Часть результатов также может быть расположена в оперативной памяти. Как и при её чтении (на этапе извлечения кода инструкции или получения входных операндов), при записи модель должна симулировать все побочные эффекты.

\item Продвижение указателя команд (\abbr advance PC) на значение, соответствующее следующей инструкции. Кроме случаев инструкций ветвления и генерации исключений, обычно его значение увеличивается на длину только что завершённой машинной команды.

При моделировании необходимо учитывать ограниченность ширины регистра \texttt{PC} и возможность его переполнения. Например, для процессора, ширина регистра PC которого составляет 16 бит, а длина инструкций — два байта:

\begin{lstlisting}
const int instr_size = 2; // 16 битный процессор
const int addr_mask = 0xffff; // маска для 16 бит
state_t cpu; // состояние процессора
...
cpu.pc = (cpu.pc + instr_size) & addr_mask;
\end{lstlisting}

\end{enumerate*}

\subsection{Особенности обработки доступов к памяти и устройствам}

Несмотря на то, что операции чтения и записи памяти присутствуют почти во всех архитектурах процессоров, за историю развития вычислительной техники было придумано неисчислимое количество способов адресации и обращения к ней. При создании программной модели приходится учитывать такие особенности работы с адресами. Не пытаясь объять необъятное, приведём лишь несколько примеров.

\begin{itemize*}

\item В архитектуре IA-32 адрес операнда в памяти может определяться несколькими регистрами и константами, закодированными в инструкции. В самом общем случае в ней определяются: сегмент, база, индекс, масштабный коэффициент, а также константа, задающая смещение, и поле для указания модификаций ширины операндов. Для контраста: в системах с процессорами MIPS для адресации используется один регистр и одна константа.

\item В ряде случаев ячейка памяти может адресоваться нулём операндов, т.е. неявно, например, располагаться на вершине стека.

\item Поддерживаемые размеры доступов в память могут быть различными. Например, хозяин за одну операцию может прочитать максимум 32 бита, тогда как в гостевой архитектуре требуемый размер считываемых данных равен 64 битам. Это усложняет моделирование атомарных операций, т.к. приходится разбивать гостевой доступ на несколько транзакций, нарушая исходные предположения о неделимости последнего. Обратная ситуация, когда, например, требуется прочитать 1 байт гостевой памяти, но хозяин может адресовать только 4 байта, тоже может привести к ошибкам в симуляции.

\item Отдельно следует отметить различия в требованиях разных систем к выравниванию (\abbr alignment) доступов в память\footnote{Блок памяти длиной $w$ является выровненным по адресу $A$, если $A = 0 \mod w$, т.е. $A$ нацело делится на $w$. При этом чаще всего рассматривается выравнивание по степеням двойки.}. Некоторые архитектуры запрещают \textit{невыровненные доступы} — при попытке прочитать или записать данные по такому адресу возникает исключение. Некоторые процессоры это позволяют, зачастую облагая такой доступ повышенным временным «пенальти».
\end{itemize*}

\section{Исключения и прерывания}

Часто при обработке текущей инструкции возникает ситуация, когда нормальное её выполнение не может быть завершено, потому что  были обнаружены недопустимые условия на входные операнды (например, целочисленное деление на ноль или недоступность памяти), или возникло какое-то внешнее условие, требующее немедленной обработки. При этом архитектурное состояние процессора изменяется определённым способом (как правило, управление передаётся на обработчик возникшей ситуации), в том числе регистр \texttt{PC} начинает указывать на новый участок кода. 

На рис.~\ref{fig:interp-cycle-expanded-exception} изображён цикл интерпретации, учитывающий тот факт, что практически в любой момент может произойти переход в состояние обработки исключительной ситуации, вносящее изменения в архитектурное состояние, после чего цикл интерпретации начинается заново уже с новым \texttt{PC}.

\begin{figure}[h!tbp]
    \centering
	\inputpicture{drawings/interp-cycle-expanded-exception}
    \caption[Цикл интерпретатора с фазой обработки исключения]{Рабочий цикл интерпретатора. Показана возможность возникновения исключительной ситуации на любой стадии симуляции}
    \label{fig:interp-cycle-expanded-exception}
\end{figure}

\subsection{Классификация исключений}

В документациях к различным процессорам~\citep{intelmanual-7vols, arm-sdg, weaver1994sparc} даны различные, зачастую внутренне противоречивые определения терминов, связанных с исключительными ситуациями. Тем не менее важно различать природу событий, их связь с текущим контекстом выполнения для того, чтобы корректно симулировать их эффекты.

Выделим основные группы исключительных событий по признакам наличия причинной связи между событиями, влиянием среды исполнения на возможность их возникновения, а также адресом возврата после их обработки. В скобках к терминам будут даны те имена, под какими они чаще всего встречаются в литературе; однако не следует полагаться на строгость данных соответствий. См. также замечания ниже.

\begin{itemize*}
    \item \textit{Синхронные с повторением текущей инструкции} (промах, \abbr fault) — событие, связанное причинно-следственно с выполнением текущей инструкции и обусловленное «неготовностью» среды исполнения к её успешному завершению. Примеры таких ситуаций: отсутствие физической страницы памяти с необходимыми данными; неготовность сопроцессора выполнять работу, т.к. он требует дополнительной инициализации. В этих случаях обработчик ситуации, находящийся в операционной системе, может модифицировать среду исполнения так, что завершение инструкции станет возможным, например, загрузить нужную страницу или включить сопроцессор. Дальнейшее возвращение на \emph{тот же} \texttt{PC} с перезапуском инструкции позволит устранить проблему прозрачно для пользовательского приложения.

    \item \textit{Синхронные без повторения текущей инструкции} (исключения, \abbr ex\-cep\-tion).  Как и в предыдущем случае, событие порождено текущей инструкцией. Однако его обработка не подразумевает её повтора, так как причина события неустранима и не связана со средой исполнения, но связана только с самой операцией и операндами. Примеры: инструкция целочисленного деления на регистр, содержащий ноль, всегда будет давать ошибку; инструкция, запрещённая к выполнению в текущем уровне привилегий, не может быть на нём исполнена никогда. Чаще всего (но не всегда!) исключения обозначают ошибку в программе. Управление после возврата из обработчика будет передано в место, не связанное с \texttt{PC} того кода, где произошло событие.

    \item \textit{Ловушки} (\abbr trap) также синхронны. При этом они обозначают явное «желание» программы быть прерванной и передать управление в определённую область кода — обработчик вызова. Примером является инструкция \texttt{SYSCALL}, вызывающая системные функции операционной системы, такие как работа с файлами, создание новых процессов и т.п. Другой пример — команда, предназначенная устройству-сопроцессору, физически отсутствующему в системе, однако ОС умеет её эмулировать и таким образом способна вернуть правильный результат прозрачно для пользовательской задачи. С точки зрения прикладного ПО ловушка — это инструкция, семантика которой определяется не спецификацией ЦПУ, а используемой операционной системой и средой исполнения.

    После обработки ловушки и возврата счётчик инструкций будет указывать на следующую команду в потоке исполнения, т.е. будет соответствовать нормальному потоку. Отметим, что разница между ловушками и исключениями минимальна. Их классификация зависит от верхнеуровневого смысла, который вкладывают в соответствующую подпрограмму-обработчик.

    \item \textit{Асинхронные прерывания} (\abbr interrupt). В отличие от всех ранее рассмотренных событий, они вызваны причинами, внешними по отношению к текущему контексту исполнения, и означают некоторое состояние внешней среды, требующее внеочередной обработки. Примеры: жёсткий диск готов передать новую порцию данных, ранее запрошенную независимым процессом; температурный датчик сигнализирует о превышении измеряемой температуры порогового значения; таймер сообщил о прошествии запрограммированного в него интервала. Прерывание никак не связано с опкодом, адресом или аргументами инструкций — оно могло произойти чуть раньше или позже, а могло и вовсе не произойти. Однако игнорировать его в общем случае нельзя. Обычно недопустимо откладывать вызов обработчика прерывания более чем на некоторый краткий период времени.

    Будет ли после возвращения из обработчика перезапущена инструкция, на которой возникло прерывание, зависит от конкретной архитектуры процессора, однако в любом случае её исполнение должно пройти таким образом, чтобы сам факт обработки был скрыт от прерванного приложения.

    \item \textit{Аварийная ситуация} (\abbr machine check, abort). Самое редкое и при этом наиболее серьёзное событие, означающее обнаруженный сбой в аппаратуре. Как и обычное асинхронное прерывание, оно не связано с работой текущей программы, но вызвано внешними обстоятельствами. Отличает от прерывания его тот факт, что обработчик аварийного сигнала обычно не может вернуть управление обратно прерванной программе, так как сам факт возникновения события означает, что состояние системы было изменено неопределённым образом. Другими словами, может оказаться, что возвращаться некуда. Содержимому памяти и регистров больше нельзя доверять.

    Не все системы поддерживают генерацию такого вида сигналов, так как для этого аппаратура должна уметь детектировать нарушения; обычно это присутствует только в дорогих высоконадёжных серверных решениях.
    Примеры аварийных ситуаций, вызывающих ситуацию «machine check»: некорректируемое повреждение содержимого оперативной памяти или кэшей; перегрев или переохлаждение узлов системы; нарушение целостности программного обеспечения, отвечающего за криптографическую верификацию загружаемого кода (что может означать попытку взлома системы через модификацию доверенных компонент системных программ).
    
    Типичная задача обработчика аварийного сигнала довольно проста — зарегистрировать факт ошибки в энергонезависимой памяти для последующего анализа и выключить или перезагрузить машину.
\end{itemize*}

Следует также отметить следующие особенности существующих центральных процессоров по отношению к исключениям.
\begin{enumerate*}
    \item Программное прерывание (\abbr software interrupt) — событие, вызываемое специальной инструкцией (например, в IA-32 это \texttt{INT}), обработка которого напоминает вызов процедуры. Т.е., несмотря на название, оно соответствует ловушке, а не прерыванию.
    \item В некоторых архитектурах, например SPARC~\citep{weaver1994sparc}, подпрограмма-обработчик синхронного события может сама выбрать, следует ли перезапускать текущую инструкцию. Для возвращения из подпрограммы-обработчика могут использоваться две различные инструкции — \texttt{RETRY} для перезапуска (в случае обработки промаха) и \texttt{DONE} для исполнения следующей команды за текущей (для выхода из обработки ловушек). Для поддержки такой возможности в архитектуру введён регистр \texttt{nPC}, в любой момент указывающий на следующую за текущей инструкцию. 
\end{enumerate*}

\subsection[Обработка исключительных ситуаций]{Обработка исключительных ситуаций при симуляции}

Существование исключений и прерываний (а они отсутствуют разве что только в узкоспециализированных микроконтроллерах) существенно усложняет логику как аппаратной системы, так и моделирующей среды. Непредсказуемость их возникновения создаёт множество веток исполнения в структурированном коде, усложняя его структуру, а также негативно влияя на скорость исполнения.

Обычный структурированный код про\-це\-дур\-ных и объек\-тно-ори\-ен\-ти\-ро\-ван\-ных языков высокого уровня состоит из вложенных вызовов процедур (методов), каждая из которых по окончании работы возвращает управление в вызвавшую процедуру по адресу, сохранённому на стеке. Однако  моделирование исключительных ситуаций подразумевает возможность их возникновения во множестве мест — индивидуальных блоках эмуляции инструкций. При этом после изменения архитектурного состояния управление должно быть передано на начало следующего цикла интерпретации.

Забегая вперёд, заметим, что особенно остро эта проблема передачи управления встаёт не в интерпретаторах, а в двоичных трансляторах, часть кода которых создаётся динамически. При этом часто при исполнении этого кода заранее нельзя сказать, какова будет структура стека в момент обнаружения исключительной ситуации, и его развёртывание до необходимого уровня вложенности с помощью серии обычных возвратов из процедур будет достаточно дорогостоящей операцией, нивелирующей преимущества быстрого исполнения.

Естественным способом передачи управления в такой ситуации является нелокальный <<прыжок>> — переход, использующий пару функций \texttt{setjmp()} и \texttt{longjump()}, описанных в стандарте библиотеки Си. Функция \texttt{setjmp} сохраняет контекст в переменной \texttt{env} и возвращает 0, если выход из неё был после её прямого вызова. Если произошёл возврат из \texttt{longjmp}, то функция возвращает ненулевое значение.
Функция \texttt{longjmp} возвращает выполнение в точку вызова \texttt{setjmp} со значением \texttt{val}. При этом все объекты с неавтоматическим выделением памяти сохраняют своё значение.

Пример использования \texttt{setjmp()} и \texttt{longjmp()}\footnote{Пример взят из Википедии: \url{http://en.wikipedia.org/wiki/Setjmp.h}.}:

\begin{lstlisting}
#include <stdio.h>
#include <setjmp.h>
 
static jmp_buf buf;
void second(void) {
  printf("second\n");/* печать на экран */
  longjmp(buf,1);/* переходит по метке buf и возвращает код 1*/
}
 
void first(void) {
  second();
  printf("first\n");/* этой печати не произойдёт*/
}
 
int main() {   
  if ( ! setjmp(buf) ) {
    first(); /* при исполнении вернёт код 0*/
  } else { /* по возвращении из longjmp вернёт 1*/
    printf("main\n");/* печать на экран*/
  }
  return 0;
}
\end{lstlisting}

Нельзя отрицать, что использование как нелокальных\footnote{То есть пересекающих границу отдельной процедуры.} переходов с помощью \texttt{longjump}, так и локальных\footnote{Происходящих внутри одной процедуры.} переходов по метке с помощью оператора \texttt{goto} языка Си нарушает модульность кода и лёгкость его чтения, а также может быть источником алгоритмических ошибок. Однако на это приходится идти ради увеличения скорости работы приложения.

\section{Реализация декодера}\label{sec:decoding}

Теория вопроса лексического анализа выражений хорошо разработана для языков высокого уровня и описывается во всех книгах, посвящённых задаче построения компиляторов~\citep{eac2011}. Считаемая классической <<Книга дракона>>~\citep{dragonbook} также подробно рассматривает вопрос разбора выражений.

\subsection{Особенности разбора машинных языков}

Машинное представление инструкций некоторой системы — всего лишь один из языков, и вся теория разбора выражений к нему применима. Например, можно генерировать лексические анализаторы с помощью Flex~\citep{flex-manual}. Однако имеются особенности, требующие для ряда важных случаев строить декодеры машинного кода более подходящими для этого способами.

\begin{description*}
    \item[Переменная или постоянная длина инструкций.] Многие RISC-процессоры имеют фиксированную длину инструкций, например, 16 или 32 бита. При этом адрес всех инструкций всегда выровнен. Для однозначного декодирования достаточно считать из памяти одно машинное слово.
    
    С другой стороны, более древние CISC-системы чаще всего используют переменную длину инструкций. Так, в архитектуре IA-32 длина инструкций может составлять от 1 до 15 байт. %Более подробно этот случай разбирается в секции~\ref{sec:variable-length}.
    \item[Префиксный код.] В подавляющем числе случаев набор инструкций определяется \textit{префиксным кодом} — никакая последовательность бит, определяющая разрешённую инструкцию, не является точным префиксом для другой инструкции. Это свойство означает  отсутствие неоднозначности при декодировании инструкций с переменной длиной. 
%     \item Логическое поле может быть раскидано по различным байтам машинного слова
    \item[Влияние режима процессора на смысл.] В значительной части архитектур процессор может находится в нескольких режимах работы, определяющих его функциональность. Например, процессоры IA-32 могут иметь следующие режимы работы\footnote{Для краткости описания здесь опущены такие режимы, как System Management Mode и VMX root/non-root.}: 16-битный реальный, 16-битный <<нереальный>>,  16-битный защищённый, 32-битный защищённый, 64-битный защищённый. Процессоры ARM могуть находиться в режимах 32-битных команд, 16-битных Thumb-команд, а также в недавно появившемся 64-битном режиме, доступном для некоторых моделей. При этом кодировка команд разных режимов может быть несовместима. Так, в архитектуре IA-32 в 64-битном режиме однобайтные последовательности из диапазона 0x40--0x4f не являются полными инструкциями, но идут как первый байт более длинных команд. В 32-битном режиме им соответствуют варианты инструкций \texttt{INC} и \texttt{DEC}. Поэтому при декодировании необходимо учитывать текущий режим процессора.
    
    \item[Странности.] Иногда ISA может иметь совершенно неожиданные особенности. Например, в Intel Itanium ширина группы из трёх инструкций, составляющих связку(\abbr bundle), равна 128 битам. При этом ширина каждой отдельной инструкции равна 41 биту, а пять оставшихся бит несут общую информацию о группе в целом (так называемый шаблон). \textit{Для некоторых} шаблонов ширина одной из инструкций удваивается до 82 бит, таким образом, в связке остаётся лишь две инструкции!
\end{description*}

\subsection{Ввод и вывод процедуры декодера}

В реальном процессоре за задачу декодирования отвечает отдельный блок логических элементов внутри микросхемы. В симуляторе ему соответствует некоторая процедура, написанная на языке программирования. Рассмотрим, что подаётся на её вход и какие результаты она должна выдавать.

Как должно быть понятно из описанного выше, на вход декодера подаётся массив байт известной длины, полученный на фазе Fetch. Кроме того, ему может быть известен текущий режим процессора и адрес начала массива в памяти гостя.

В результате работы декодер должен вернуть код ошибки и результаты анализа последовательности в виде списка полей результата (мы вернёмся к ним чуть позже). При этом возможны следующие значения для кода ошибки.

\begin{enumerate*}
    \item Декодирование успешно (код 0). Массив байт был распознан как допустимая инструкция, и список полей содержит информацию о коде операции и её аргументах.
    \item Декодирование неуспешно (код 1). Ни одна инструкция, определённая в архитектуре, не соответствует входному массиву байт. При этом содержимое полей результата не несёт смысла. Что происходит в этой ситуации дальше на этапе исполнения? Это зависит от архитектуры. Чаще всего невозможность декодировать ведёт к генерации исключения\footnote{Подчеркнём, что эта ситуация не является внутренней ошибкой самого симулятора — поведение процессора на неизвестных инструкциях должно быть описано в документации и является штатной ситуацией в его работе.}. В некоторых случаях некорректная инструкция может быть воспринята как \texttt{NOP} — отсутствие операции.
    \item Для ISA с переменной длиной инструкций возможна третья ситуация — входных данных недостаточно для принятия однозначного решения (код -1). Другими словами, на вход декодера передали только часть инструкции, и он, не имея информации о том, какие байты идут в памяти дальше, сообщает об этом.
\end{enumerate*}

На рис.~\ref{fig:variable-length} приведён пример алгоритма, сочетающего в себе итерации фаз Fetch и Decode и позволяющего провести декодирование для инструкций с переменной длиной.

\begin{figure}[htb]
    \centering
	\inputpicture{drawings/variable-length}
    \caption{Блок-схема декодирования, учитывающая переменную длину инструкции}
    \label{fig:variable-length}
\end{figure}

У наблюдательного читателя может появиться вопрос: зачем использовать этот достаточно сложный и наверняка неэффективный алгоритм? Поскольку размер самой длинной инструкции всегда известен, а используемый код префиксный, то можно сделать Fetch последовательности, достаточной для вмещения как минимум одной инструкции. Затем декодировать её первый префикс, а оставшиеся <<лишние>> байты проигнорировать.

К сожалению, этот метод может генерировать исключения, отсутствующие в реальной системе, при попытке декодирования инструкций, находящихся близко к концу страницы или сегмента симулируемой памяти. Это связано с тем, что в системах, использующих механизмы страничной адресации или сегментации, разные диапазоны памяти имеют разные свойства. Если при чтении массива для декодирования <<с запасом>> пересекается граница между двумя такими диапазонами, и второй из них при чтении вызывает исключение, то и всё декодирование будет давать ложное исключение, тогда как на самом деле текущая инструкция корректна, не пересекает границ и должна быть успешно распознана (рис.~\ref{fig:page-crossing-decode}). Для того, чтобы избежать подобной ситуации, в алгоритме рис.~\ref{fig:variable-length} на каждой итерации читается и добавляется только один байт.

\begin{figure}[htb]
    \centering
	\inputpicture{drawings/page-crossing-decode}
    \caption[Пересечение границы страниц при декодировании]{Пересечение границы страниц при декодировании, вызывающее ложное исключение}
    \label{fig:page-crossing-decode}
\end{figure}

\subsection{Поля результата}

Какую информацию должны содержать поля результата при успешном декодировании?

\begin{itemize*}
    \item Код операции (опкод), определяющий функцию, выполняемую инструкцией.
    \item Длину инструкции для ISA, в которых она является переменной.
    \item Информацию о каждом операнде. Для регистров это его порядковый номер, ширина и тип. Для областей в памяти — адрес и ширина. Для адресов в инструкциях перехода — относительное смещение относительного текущего положения или абсолютный адрес, а также номер сегмента.
    \item Дополнительная информация, необходимая для нужд исполнения или симулятора. К ней может относиться наличие префиксов, модифицирующих операцию или характеристики операндов и т.п. Кроме того, для нужд отладки гостя декодер может также создавать строку ассемблера, соответствующего инструкции.
\end{itemize*}

Если сохранять результат в виде структуры языка Си, то она будет иметь приблизительно следующую форму:

\begin{lstlisting}
typedef struct decode_result {
    int length; // длина инструкции
    opcode_t opcode; // код операции
    int num_operands; // число операндов инструкции
    struct {
        operand_type_t type; // тип операнда
        union {
            int32    i32;
            int16    i16;
            int8     i8;
            float    f32;
            offset_t off32;
        } value; // варианты хранимого значения
    } operands[MAX_OPERANDS]; // массив с операндами
} decode_result_t;
\end{lstlisting}

Для каждой конкретной архитектуры поля данной структуры будут свои собственные, отражающие особенности её формата инструкций.

\subsection{Декодирование как распознавание шаблонов}

В документации на центральные процессоры формат инструкций чаще всего описывается в виде таблиц, определяющих, какие биты машинного представления инструкции определяют логические поля, такие как опкод и операнды (см. рис.~\ref{fig:bitfields}). Группы инструкций могут описываться одним и тем же форматом. Верно и обратное — несколько форматов могут описывать варианты одной и той же инструкции. При этом полное число различных форматов зависит от самой ISA и может быть достаточно велико. Задача декодера состоит в сопоставлении входной строки данному набору шаблонов, нахождении совпадения, вычислении значений отдельных битовых полей и формировании значений полей логических. 

\begin{figure}[htb]
    \centering
\bytefieldsetup{bitwidth=0.36cm, endianness = big}
\begin{bytefield}[]{32}
    \bitheader{31,30,29,25,24,19,18,14,13,12,5,4,0} \\
    \bitbox{2}{10} & \bitbox{5}{rd} & \bitbox{6}{op3} & \bitbox{5}{rs1} & \bitbox{1}{\tiny i=0} & \bitbox{8}{—} & \bitbox{5}{rs2} \\[0.25cm]
    \bitbox{2}{10} & \bitbox{5}{rd} & \bitbox{6}{op3} & \bitbox{5}{rs1} & \bitbox{1}{\tiny i=1} & \bitbox{13}{simm13}
\end{bytefield}
    \caption{Описание битовых полей инструкции. Пример взят из описания архитектуры SPARC~\citep{weaver1994sparc}, инструкция \texttt{ADD} и её варианты}
    \label{fig:bitfields}
\end{figure}

Для корректного декодирования любой входной последовательности должен соответствовать максимум один шаблон. Если совпадений больше одного, то либо в кодировке инструкций, либо в реализации декодера присутствует ошибка. %Если совпадений нет, то результат 

\subsubsection{Связь битовых и логических полей инструкции}

Логическое поле инструкции, описывающее опкод или один из логических операндов, может зависеть от нескольких битовых полей и режима процессора довольно сложным образом. При этом функция вычисления логического поля также может быть комплексной. Приведём лишь два примера.

\begin{enumerate*}
    \item В Intel Itanium~\citep{itanium-sdm} для формата арифметических инструкций A4 значение константы \texttt{imm\textsubscript{14}} формируется из трёх разнесённых битовых полей: одного бита \texttt{s}, шести бит \texttt{imm\textsubscript{6a}} и семи бит \texttt{imm\textsubscript{7b}}, после чего оно расширяется знаком до 64 бит и используется в операции сложения.
    
    \item В последних ревизиях архитектуры Intel IA-32~\citep{intel-x-reference} номер одного из операндов (от нуля до 31) —   векторного регистра ZMM — в 64-битном защищённом режиме процессора определяется как комбинация следующих битовых полей: три бита \texttt{ModRM.Reg}, один бит \texttt{REX.R} и один бит \texttt{EVEX.\={R}}, причём последний из них следует инвертировать.
\end{enumerate*}

\subsection{Оптимизация процесса декодирования}

Число шаблонов декодера, с которыми придётся сравнивать каждую входную последовательность, для достаточно сложного набора инструкций может оказаться огромным. Линейный поиск в содержащей их таблице может оказаться недопустимо медленным. Для её хранения может потребоваться значительный объём памяти.

По этим причинам стараются трансформировать шаблоны в другой формат — дерево поиска. Двигаясь от его корня к листьям и проверяя в каждом узле лишь совпадения значений для подмножества битовых полей, а не для всего входного массива декодируемых байт, удаётся уменьшить как среднее число требуемых сравнений, так и объём необходимой для хранения структур декодера памяти.

% На рис.~\ref{fig:decode-tree}.
% 
% \begin{figure}[htb]
%     \centering
%     \bytefieldsetup{bitwidth=0.25cm, endianness = big}    
%     \begin{bytefield}[]{16}
%         \bitbox{2}{00} & \bitbox{14}{b} \\[0.25cm]
%         \bitbox{2}{01} & \bitbox{14}{b} \\[0.25cm]
%         \bitbox{2}{10} & \bitbox{2}{01} & \bitbox{12}{d} \\[0.25cm]
%         \bitbox{2}{10} & \bitbox{3}{100} & \bitbox{11}{f}
%     \end{bytefield}
% 
%     \begin{tikzpicture}[>=latex,font=\small]
%         \node {\todo{Дерево}}
%           child {node{a=00}
%             child {node{OK}}
%             }
%           child {node{a=01}
%             child {node{OK}}
%             }
%           child {node{a=10}}
%           child {node{a=11}};
%         
%         
%     \end{tikzpicture}
%     \caption[Таблица шаблонов и дерево декодирования]{Пример таблицы шаблонов некоторого набора инструкций и эквивалентное ему дерево декодирования}
%     \label{fig:decode-tree}
% \end{figure}

% \section[Преимущества и недостатки интерпретатора]{Преимущества и недостатки интерпретатора}
% 
% Главным преимуществом рассмотренной схемы является её простота в реализации, модификации и отладке. Практически всегда в проектах по созданию программной модели нового процессора первым этапом является разработка интерпретационной модели, которая затем используется как эталон для тестирования последующих улучшений модели, оптимизирующих эффективность исполнения.
% 
% Основным недостатком интерпретатора является низкая скорость. Дело в том, что если на модели ЦПУ исполняется какой-нибудь цикл (например, копирование памяти из одного места в другое), то одни и те же команды декодируются множество раз. Если данный цикл был декодирован один раз и для него был сгенерирован код, который моделирует его работу, то в дальнейшем стадию декодирования при входе в этот блок можно было бы опустить. Модели, работающие по такой схеме, принадлежат к классу трансляторов.
% 
% Однако не всегда транслятор быстрее интерпретатора. Как можно видеть из общего алгоритма работы (рис.~\ref{fig:translator}), если приложение, которое исполняется на моделируемом ЦПУ, не содержит (или содержит мало) постоянных циклов, то транслятор будет все время обнаруживать «новый» код, что приведет к постоянным тратам времени на кодогенерацию\footnote{Кроме того, в трансляторе есть дополнительные накладные расходы на  контролирование возможности использования самомодифицирующегося кода; описание механизмов выходит за рамки данной главы и описано в главе~\ref{bt}.}. 
% 
% \begin{figure}[htb]
%     \centering
%     % \includegraphics[width=0.6\textwidth]{./translator-crop}
%     \begin{tikzpicture}[>=latex,
%     action/.style={ rectangle, draw, node distance=2cm, text badly centered, text width=2.5cm},
%     complexaction/.style={rectangle, draw, rounded corners, node distance=2cm, text badly centered},
%     choice/.style={diamond, draw, aspect=2, node distance=2cm, text badly centered, text width=2.5cm, inner sep=0cm}
%     ]
%     \node[choice]                           (is-translated) {\scriptsize Инструкция транслирована?};
%     \node[action, below of=is-translated, yshift=-1cm]   (fetch-instr)   {Извлечь инструкцию};
%     \node[action, below of=fetch-instr]     (decode)        {Декодировать};
%     \node[complexaction, matrix, below of=decode, yshift=-1cm, row sep=0.1cm]   (generate-code) {
%         \node{Сгенерировать управляющий код}; \\
%         \node[complexaction] {Управление хранилищем кода}; \\
%         \node[complexaction] {Генерация кода}; \\
%         \node[complexaction] {Оптимизация}; \\
%         };
%     \node[choice, below of= generate-code, yshift=-1cm]  (end-block)     {Конец блока?};
%     \node[action, below of= end-block]      (execute)       {Исполнять};
%     
%     \path[->, draw] (execute.south) |- ([xshift=-3cm, yshift=-1cm] execute.west) |- ([yshift=0.6cm] is-translated.north) -- (is-translated.north);
%     \path[->, draw] (is-translated.east) -|  ([xshift=2.5cm] execute.east) node[near start, above] {Да} -- (execute.east);
%     \path[->, draw] (is-translated.south) --  (fetch-instr.north) node[midway, right] {Нет};
%     \path[->, draw] (end-block.west) -| ([xshift=-2.5cm] end-block.west)  node[very near start, above] {Нет} |- (fetch-instr.west);
%     \path[->, draw] (end-block.south) -- (execute.north) node[midway, right] {Да};
%     \path[->, draw] (fetch-instr.south) -- (decode.north);
%     \path[->, draw] (decode.south) -- (generate-code.north);
%     \path[->, draw] (generate-code.south) -- (end-block.north);
%     
%     \end{tikzpicture}
%     \caption{Алгоритм работы транслятора}
%     \label{fig:translator}
% \end{figure}
% 
% По этой причине часто применяются гибридные модели ЦПУ, в которых присутствуют как интерпретатор, так и транслятор. Когда модель исполняет «незацикленный» код, работает интерпретатор. Как только обнаруживается «горячий», т.е. часто исполняемый, цикл, моделирование его выполняется транслятором~\citep{TophamJones2007}.

\section[Увеличение скорости работы]{Увеличение скорости работы интерпретатора}
\dictum[Кот Матроскин]{А я ничего не буду выписывать — я экономить буду!}

Главным преимуществом рассмотренной схемы является её простота в реализации, модификации и отладке. Практически всегда в проектах по созданию программной модели нового процессора первым этапом является разработка интерпретационной модели, которая затем используется как эталон для тестирования последующих улучшений модели, оптимизирующих эффективность исполнения.

Основным недостатком интерпретатора является низкая скорость. Были разработаны многочисленные приёмы увеличения скорости интерпретации. Рассмотрим базовые идеи, используемые в них.

\subsection{Шитая интерпретация}

Одной из причин низкой скорости работы является неэффективное использование различных аппаратных ресурсов хозяйской системы, призванных уменьшить влияние явлений, разрушительных для конвейерной обработки. Так, из-за использования единого \texttt{switch} в теле цикла, из которого передача управления может быть осуществлена  во множество мест, предсказатель переходов процессора не может каждый раз правильно предугадать адрес инструкции перехода, что вызывает сброс конвейера и задержку в несколько тактов. Этот негативный эффект проявляется в начале обработки каждой новой гостевой инструкции. Вместо концентрации условного перехода в одном месте  желательно <<размазать>> его по многим местам в коде, уменьшив в каждом из них число вариантов адреса (в идеале — до одного). Этого можно достичь, если вызывать обработчик следующей инструкции сразу после конца работы текущей инструкции, без возвращения в общий цикл. Такой алгоритм интерпретации называется \textit{шитым}~\citep{forth-rus88} (\abbr threaded), см. рис.~\ref{fig:switched-threaded-interp}. 

\begin{figure}[htb]
    \centering
    \subfigure[Переключаемый интерпретатор]{
	\inputpicture{drawings/switched-interp}
    }
    \subfigure[Шитый интерпретатор]{
	\inputpicture{drawings/threaded-interp}
    }  
    \caption{Сравнение последовательности передачи управления для переключаемой и шитой интерпретаций}
    \label{fig:switched-threaded-interp}
\end{figure}


Пример реализации шитой интерпретации в псевдокоде дан ниже. Предполагается, что этап декодирования уже проведён, и в памяти содержится информация о том, какой будет следующая инструкция.

\begin{lstlisting}
// Массив labels содержит адреса переходов для всех обработчиков
labels = [INSTR_A, INSTRb, ... INSTR_X, ... INSTR_Y ...]; 

INSTR_X: // Текущая инструкция X
    X_handler(operands, PC); // обработчик инструкции
    PC++;
    goto label[PC]; // Сразу к обработчику новой инструкции
\end{lstlisting}

Для реализации шитой схемы используемый для написания модели язык должен поддерживать указатели на метки в коде. Стандарт ANSI Си не позволяет этого делать. Но, например, в GNU C доступно соответствующее расширение языка --- оператор \texttt{\&\&label}.

\subsection{Интерпретация с кэшированием}

Промежуточным звеном между интерпретатором и транслятором является кэширующий интерпретатор. В нём вместо достаточно медленной отдельной фазы генерации кода используется только кэш (промежуточное хранилище с быстрым доступом) декодированных инструкций (рис.~\ref{fig:cached-interp}). Если он реализован эффективно, то решение будет сбалансировано: при исполнении зацикленного кода модель ЦПУ будет достаточно быстрой, а при исполнении линейного кода будет незначительно проигрывать простому интерпретатору, рассмотренному ранее.

\begin{figure}[htb]
    \centering
	\inputpicture{drawings/cached-interp}
    \caption{Схема работы кэширующего интерпретатора}
    \label{fig:cached-interp}
\end{figure}

\section[Модификация интерпретатора]{Модификация интерпретатора — добавление новых инструкций}

Часто возникает задача расширения функциональности некоторой модели для представления функциональности нового процессора, отличающегося от старого наличием новых инструкций и дополнительных регистров процессора. Например, начиная с Intel Pentium IV в 2001 году были введены команды семейства SSE2, работающие с регистрами \texttt{XMM0}--\texttt{XMM7}.

Для того чтобы минимально модифицировать старый, хорошо отлаженный код модели, но при этом и поддержать новые системы, можно воспользоваться тем обстоятельством, что оригинальная модель не распознаёт новые инструкции как допустимые и должна вызвать обработку исключения \texttt{\#UD} (\abbr undefined opcode). Однако, мы даём модели <<второй шанс>>, вызывая второй декодер новых инструкций. Если он подтверждает, что может декодировать переданный ему машинный код, вызывается новая часть интерпретатора, ответственная за новый набор инструкций (рис.~\ref{fig:chained-interp}). 

\begin{figure}[h!tb]
    \centering
	\inputpicture{drawings/chained-interp}
    \caption[Ступенчатая схема вызова декодеров]{Ступенчатая схема вызова декодеров при обнаружении инструкции, не поддерживаемой оригинальной моделью. При обнаружении в потоке инструкций машинного кода, не распознаваемого D1, управление передаётся на D2}
    \label{fig:chained-interp}
\end{figure}

Очевидно, что данную схему можно расширить для каскадного включения большего числа новых наборов инструкций. Её достоинство — гибкость подключения новой функциональности к уже существующей модели; дополнительные декодеры и симуляторы инструкций могут быть взяты из независимых источников и сравнительно легко адаптированы для использования. Недостаток тоже очевиден: последовательный вызов декодеров менее быстр, чем реализация, объединяющая их все в единую сущность.

\section{Простой пример}

Приведём код (на языке Си) интерпретационной модели некоторого упрощённого для целей данного примера процессора со следующей архитектурой.

\subsection{Регистры}

В рассматриваемом примере три регистра для арифметических операций и один указатель текущей инструкции.
\begin{itemize*}
\item    \texttt{R0}, \texttt{R1}, \texttt{R2} — регистры общего назначения;
\item    \texttt{IP} — указатель команд.
\end{itemize*}

\subsection{Инструкции}

Набор инструкций включает в себя только две арифметические операции, а также команды для работы с памятью.

\begin{itemize*}
    \item \texttt{ADD} — сложение значений в двух регистрах;
    \item \texttt{SUB} — вычитание значений двух регистров;
    \item \texttt{LOAD} — загрузка ячейки памяти в регистр;
    \item \texttt{STORE} — сохранение регистра в памяти.
\end{itemize*}

\subsection{Код модели}

\paragraph{Структура данных для хранения результата декодирования} 
\begin{lstlisting}
struct DecodedInstr {
    enum Operation Op;
    enum Argument Arg1;
    enum Argument Arg2;
};
\end{lstlisting}

\paragraph{Архитектурное состояние модели}
\begin{lstlisting}
int R0, R1, R2, IP;  // Модель регистров
class Memory Mem;    // Модель внешней памяти
\end{lstlisting}

\paragraph{Алгоритм симуляции}
\begin{lstlisting}
for (;;) { // бесконечный цикл
    int Instr = FetchInstr();
    struct DecodedInstr DecInstr = Decode(Instr);
    Execute(DecInstr);
}

int FetchInstr() {
    return Mem.Load32Bits(IP); // Загружаем 4 байта из памяти по адресу PC
}

struct DecodedInstr Decode(int Instr) {
    switch (Instr) { // Перебираем все реализованные инструкции
    case 0: // ADD R0, R0
        return {.Op = OP_ADD, .Arg1 = ARG_R0, .Arg2 = ARG_R0};
    case 1: // ADD R0,R1
        return {.Op = OP_ADD, .Arg1 = ARG_R0, .Arg2 = ARG_R1};
    // ...
    }
}

void Execute(struct DecodedInstr DecInstr) {
    int *Arg1, *Arg2;  // Указатели на аргументы операции
    // Какой первый аргумент операции?
    switch (DecInstr.Arg1) {
        case ARG_R0: Arg1 = &R0; break;
        case ARG_R1: Arg1 = &R1; break;
        case ARG_R2: Arg1 = &R2; break;
    }
    // Какой второй аргумент операции?
    switch (DecInstr.Arg2) {
        case ARG_R0: Arg2 = &R0; break;
        case ARG_R1: Arg2 = &R1; break;
        case ARG_R2: Arg2 = &R2; break;
    }
    // Выполнить операцию
    switch (DecInstr.Op) {
    case OP_ADD:
        *Arg1 += *Arg2;
        IP += 4; // Продвинуть указатель команд на следующую инструкцию
        break;
    case OP_SUB:
        *Arg1 -= *Arg2;
        IP += 4; 
        break;
    case OP_LOAD:
        *Arg1= Mem.Load32Bits(*Arg2);
        IP += 4; 
        break;
    // ...
    }
}
\end{lstlisting}


\section{Заключительные замечания}

Проект Bochs~\citep{bochs} является хорошим примером зрелого интерпретатора, содержащего сложную модель процессора для существующей архитектуры IA-32. В технических заметках к программе~\citep{bochs-under-hood} её авторы описывают множество полезных приёмов, применимых как к организации модели-интерпретатора для процессора любой архитектуры, так и специфичных для архитектуры IA-32, являющейся одной из сложнейших в реализации. Подробное описание техник оптимизаций, используемых при создании симулятора, использующего интерпретатор, даны в~\citep{lifshitz11zsim}.

\input{interpretation-questions}


\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

