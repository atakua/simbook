% Copyright (c) 2016 Grigory Rechistov <grigory.rechistov@gmail.com>
% This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Worldwide.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/.

\chapter[Моделирование полной платформы]{Моделирование полной платформы. Дискретная симуляция событий}\label{fullplatform}

\dictum[Китайская пословица]{Путь в тысячу миль начинается с одного шага}

В предыдущих главах подробно разбираются различные методики эффективного моделирования центральных процессорных устройств (точнее, пары «процессор плюс рудиментарная модель внешней памяти»). Однако современные вычислительные комплексы сложнее в своём устройстве: во-первых, они  состоят из множества независимых устройств, большинство которых сильно отличается от ЦПУ по принципам своей работы (и, как мы дальше увидим, их симуляция также производится  другим образом); во-вторых, в одной системе может быть больше одного процессора. В реальности все устройства должны работать одновременно, тогда как модели исполняются последовательно в одном потоке (вопросы параллельных моделей составляют отдельную объёмную тему и будут рассмотрены в главе \ref{parallel}).
% Рассмотрим существующие подходы к решению указанных задач.

В этой главе рассматривается работа и моделирование другого класса устройств на примере периодического таймера. Затем новая схема обобщается на более общий класс устройств. В конце главы описывается принцип создания моделей систем, включающих в себя различные типы устройств.

\section{Полная платформа}

В главе \ref{interpretation} был очерчен минимальный набор устройств (рис. \ref{fig:cpu-mem}), необходимый для разработки модели процессора. Конечно же, полезность столь ограниченной системы невелика. В настоящее время даже самые крошечные микроконтроллеры не используются без нескольких дополнительных периферийных устройств, коллективно называемых \textit{платформой}. На рис. \ref{fig:full-platform} приведён пример небольшой системы, содержащей некоторые типы устройств, встречаемых в реальности.

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/full-platform}
    \caption[Модель простой полной платформы]{Модель простой полной платформы. Используемые обозначения: CPU — центральный процессор, MMU — блок управления памятью (\abbr memory management unit), RAM — оперативная память (\abbr random access memory), PIC — контроллер прерываний (\abbr programmable interrupt controller), PIT — таймер (\abbr programmable interrupt timer)}
    \label{fig:full-platform}
\end{figure}

Реальные системы, конечно же, устроены более сложно — число устройств в них значительно больше, а типы связей между ними более разнообразны (рис. \ref{fig:real-full-platform}).

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/real-full-platform}
    \caption[Модель более сложной платформы]{Модель более сложной платформы. Дополнительные устройства: L\$ — кэш-память (см. главу \ref{caches}), PMU — устройство управления энергопотреблением (\abbr power management unit), ROM — постоянное запоминающее устройство (\abbr read-only memory), Bridge — мосты, соединяющие несколько нижележащих устройств с общей шиной, Video — графический процессор, Monitor — графический монитор, USB — устройства, подключенные по универсальной последовательной шине (\abbr universal serial bus). Штриховыми линиями показаны связи для передачи прерываний, пунктирными — управление энергопотреблением}
    \label{fig:real-full-platform}
\end{figure}

\section{Периодический таймер}

Рассмотрим задачу моделирования класса устройств, часто встречаемых в вычислительных системах — таймер. Основная его задача — по истечении запрограммированного в него интервала времени сгенерировать сигнал — прерывание, которое будет получено другим устройством, например, центральным процессором или контроллером прерываний. На практике таймеры используются для всевозможных задач, от слежения за текущей календарной датой до управления переключением приложений в многозадачных операционных системах. В одной системе их может быть несколько; так, в IBM PC могут присутствовать следующие устройства (или их функциональные аналоги), работающие в качестве таймеров: PIT (Intel 8254, содержит три таймера), RTC (Motorola MC146818), таймер в составе LAPIC, высокоточный HPET~\cite{hpet}.

Таймеры различаются между собой частотой используемого в них тактового генератора, разрядностью используемых счётчиков, возможностью генерировать однократные или периодические прерывания и другими свойствами.
На рис. \ref{fig:periodic-timer} изображёно возможное строение такого устройства. Рассмотрим его основные составляющие.

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/periodic-timer}
    \caption[Внутреннее устройство таймера]{Внутреннее устройство таймера}
    \label{fig:periodic-timer}
\end{figure}

\begin{itemize*}
    \item CLK — вход для периодического сигнала с кварцевого генератора фиксированной частоты $F$. %Он задаёт наименьшую длительность периода, который таймер способен отслеживать.
    \item REF — вход для задания значения внутреннего регистра \texttt{reference}. В данном примере он имеет ширину в 16 бит.
    \item \#ENABLE — вход для сигнала, разрешающего работу таймера. Если ENABLE = 0, то сигнал CLK игнорируется (так как он подвернается операции «логическое И» с ENABLE).
    \item \texttt{counter} — счётчик колебаний. Когда ENABLE = 1, после каждого входного импульса CLK значение \texttt{counter} увеличивается на единицу.
    \item RESET — сигнал для сброса значения \texttt{counter} в ноль.
    \item Компаратор, сравнивающий значения \texttt{reference} и \texttt{counter}. Если они равны, на его выходе устанавливается логическая единица, иначе — ноль.
    \item \#INT — выход таймера. Появление на нём импульса для подключенного к нему устройства означает возникновение прерывания, требующего обработки.
\end{itemize*}

Внутренние процессы, происходящие при работе таймера, проиллюстрированы на рис. \ref{fig:counter-diagram}.

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/counter-diagram}
    \caption[Временнáя диаграмма внутренних процессов]{Временнáя диаграмма внутренних процессов таймера}
    \label{fig:counter-diagram}
\end{figure}

Временнáя диаграмма значений на выходе \#INT после задания \texttt{reference} и установки \#ENABLE в 1 приведена на рис. \ref{fig:timer-diagram}.

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/timer-diagram}
    \caption[Временнáя диаграмма \#INT]{Временнáя диаграмма \#INT}
    \label{fig:timer-diagram}
\end{figure}

Обратимся теперь к задаче написания модели этого таймера. В зависимости от того, что требуется моделировать — внутренние процессы или только внешние эффекты, — будут различаться и организации моделей.

\subsection{Симуляция с фиксированным шагом}\label{sec:time-stepped}

Первая идея, возникающая после изучения спецификации подобного цифрового устройства — написать модель, состояние которой вычисляется и обновляется регулярно с интервалом, равным периоду работы самого часто имеющегося в ней сигнала, то есть тактового генератора.

В этом случае модель должна корректно реагировать на внешние воздействия по входам CLK и \#ENABLE, а также на изменение \texttt{reference} через запись в регистр REF.

Архитектурное состояние таймера можно описать несколькими переменными для хранения его регистра и счётчика:

\begin{lstlisting}
uint16_t reference;
uint16_t counter;
\end{lstlisting}

Для каждого входа необходимо предоставить свою функцию, моделирующую эффекты, возникающие при воздействии на него:

\begin{lstlisting}

on_ref(uint16_t new_val) { // Вызывается при обновлении REF
    reference = new_val;
}

on_clk() { // Вызывается на каждом такте CLK
  if (enable)
        counter +=1;
  if (counter == reference) {
        raise_int(); // #INT = 1
        on_reset();
  } else {
        lower_int(); // #INT = 0
  }
}

on_reset() { // Вызывается при RESET = 1
    counter = 0;
}
\end{lstlisting}


Данный подход — симуляция \textit{с фиксированным шагом} (\abbr time stepped)~\cite{ferscha-1995-pdes}. Он основан на том, что для цифровых систем, управляемых тактовым генератором с фиксированной частотой $F$, существует минимальный интервал времени $\Delta t = \frac{1}{F}$, разделяющий события. Симулируемое время продвигается небольшими скачками $\Delta t$ фиксированной длины.

Задача симулятора, использующего эту модель в своём составе, на каждом симулируемом такте вызывать \texttt{on_clk()} для этой модели. Если в системе будет несколько устройств, каждое из них также должно предоставить свою реализацию \texttt{on_clk()}. На каждом шаге вызываются все методы \texttt{on_clk()} всех устройств. При этом генерируются все события, которые должны произойти на этом шаге (рис. \ref{fig:time-stepped-sim}).

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/time-stepped-sim}
    \caption[Симуляция с фиксированным шагом]{Симуляция с фиксированным шагом нескольких устройств}
    \label{fig:time-stepped-sim}
\end{figure}

В функциональных моделях соотношение частот внутренних событий (т.е. реакций на сигнал с тактового генератора) и внешних (взаимодействие с другими моделями) велико. Бóльшую часть времени симулятор будет вызвывать \texttt{on_clk()} в очередной модели устройства, только чтобы изменить её внутреннее состояние. Это обстоятельство ограничивает скорость симуляции, так как функциональные модели систем используются для изучения взаимодействий их компонент, а не их внутренних процессов.

Проиллюстрируем этот факт. Типичные значения параметров работы таймера:

\begin{itemize*}
    \item $F \approx 10^7\ \text{Гц}$;
    \item $\mathtt{reference} > 10^3$;
    \item изменения \#ENABLE — не чаще одного раза в 100 секунд.
\end{itemize*}

Из этого следует, что внешне видимый эффект (\#INT = 1) происходит примерно один раз в $10^3$ тактов CLK. Если пересчитать период в такты центрального процессора (работающего на частотах порядка $10^9$ Гц), то прерывания к нему будут приходить один раз в $10^5$ тактов. Остальные 99999 вызовов симуляции таймера не будут создавать каких-либо внешних эффектов.

\subsection{Очередь событий}

Из этого ключевого наблюдения следует следующая оптимизация: моделировать лишь внешние эффекты работы устройства без детальной симуляции внутренних процессов. Для таймера это означает, что при симуляции достаточно в правильные моменты в симулируемом времени вызывать прерывание \#INT (рис. \ref{fig:timer-events}).

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/timer-events}
    \caption[Симуляция только внешних событий таймера]{Симуляция только внешних событий таймера}
    \label{fig:timer-events}
\end{figure}

Для моделирования событий в симуляторе должен храниться их список — \textit{очередь событий}. Для того, чтобы упорядочить события, используются значения их моментов наступления — \textit{меток времени}. Каждое моделируемое событие хранит свою метку\footnote{Значения меток могут быть выражены в абсолютной форме — от начала симуляции, — или в относительной, в виде смещения от ближайшего предыдущего события. Обе формы эквивалентны и могут быть переведены друг в друга. Далее для иллюстрации идей в данной главе всюду будет использоваться относительное время — \textit{дельта} между событиями.}, а также информацию о том, какие действия над какими объектами должны произойти. Прогресс симуляции в целом отслеживается в переменной, хранящей текущее симулируемое время. В псевдокоде всё это можно выразить так\footnote{В данном примере для хранения очереди используется массив; это сделано для упрощения иллюстрации. На практике для подобной задачи рекомендуется использовать более адекватные структуры хранения данных.
% О требованиях к очереди событий рассказывается в секции \ref{sec:}
}:

\begin{lstlisting}
// Структура для хранения отдельных событий
struct event_t { 
    time_t delta; // Интервал времени до совершения события
    dev_t *device; // Объект, который будет
    (*function)(dev_t *dev); // Метод объекта, вызываемый при событии
}
struct event_t event_queue[100]; // Массив для хранения очереди событий
time_t tsim = 0; // Текущее значение симулируемого времени
\end{lstlisting}

Процесс симуляции состоит в обходе очереди событий в порядке возрастания абсолютных значений меток времени и выполнении действий, связанных с ними:

\begin{lstlisting}
simulate() {
    // Предполагаем, что в очереди события уже упорядочены
    for (int i = 0;
         i < 100;
         i++
    ) {
        struct event_t *e = &event_queue[i]; // Текущее событие
        e->function(e->device); // Выполняем его метод
        tsim += e->delta; // Продвигаем симулируемое время
    }
}
\end{lstlisting}

Рассмотрим, каким образом в терминах данной абстракции выражаются различные детали работы таймера, ранее рассмотренные в секции \ref{sec:time-stepped}.
\begin{itemize*}
    \item Поступление сигнала CLK не моделируется. Таким образом, при симуляции событий экономится время, которое при симуляции с фиксированным шагом тратилось на его обработку.
    \item Перевод \#ENABLE в ноль означает, что вы будущем прерывания, связанные с этим таймером, не произойдут. Все запланированные в очереди события, связанные с ним, должны быть найдены и удалены.
    \item Изменение \texttt{reference} означает, что период генерации прерываний \#INT изменился. Это означает, что  запланированные вызовы таймера в будущем произойдут в другие моменты. Необходимо удалить их из очереди событий и добавить новые, со значениями меток времени, соответствующими новому периоду.
\end{itemize*}

Данная схема удобна тем, что легко расширяется на систему, состоящую из нескольких взаимодействующих устройств. Так как все они хранят свои события в общей очереди, при симуляции они будут вызываться в правильном порядке, согласно меткам времени.

% \subsection{Дискретность событий и времени}
% 
% Во-первых, напомним, что необходимое условие для моделирования системы — возможность полного описания её состояния (получаемого как сумма состояний входящих в неё подсистем, т.е. устройств) в конечном количестве ячеек памяти. Любое событие заключается в изменении этого состояния.
% 
% В реальных электронных системах практически все процессы передачи информации происходят в течение некоторого промежутка времени. Например, при передаче 8 бит по кабелю последовательного порта существует момент начала передачи, соответствующий первому биту, и момент, соответствующий передаче последнего.
% 
% В дискретной модели событий мы предполагаем, что каждое событие и связанные с ним изменения в состоянии модели происходят «мгновенно» в момент, соответствующий моменту завершения процесса. Таким образом, мы избавляемся от необходимости изучать течение события целиком. Если окажется, что точности такого представления недостаточно, единое событие заменяется на несколько более мелких, каждое из которых дискретно.
% 
% Окружающее нас время непрерывно, и не существует общепризнанных физических доказательств его дискретности, т.е. существования мельчайшего неделимого промежутка времени. Поэтому и дискретные события могут быть привязаны к непрерывным моментам времени. Однако в цифровых синхронных системах время дискретно, при этом мельчайшим интервалом является один цикл генератора тактовых импульсов, причем моменты дискретных событий в такой системе привязаны к границам тактов.
% 
% Уточним дополнительно понятие «событие»: изменение состояния системы или порождение одного или более новых событий, которые запланированы произойти в будущем. Например, некоторый таймер, будучи включённым, генерирует прерывание каждые 10 тактов. Тогда событие этого устройства заключается в изменении состояния сигнальной шины и создании следующего события, отдалённого на 10 тактов в будущее.

\subsection{Отложенный ответ}

Рассмотрим более сложную модель и ещё один важный сценарий взаимодействия устройств в реальных системах (рис. \ref{fig:delayed-response}).

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/delayed-response}
    \caption[Взаимодействие с отложенным ответом]{Взаимодействие с отложенным ответом}
    \label{fig:delayed-response}
\end{figure}

Устройство \texttt{dev1} запрашивает данные, передавая их адрес по шине \texttt{address}. Устройство \texttt{dev2} должно вернуть требуемое значение по шине \texttt{data}. Однако оно не может сделать это сразу после запроса, например, потому что это требует длительного вычисления или обращения к медленному хранилищу. Чтобы не терять время в ожидании ответа, \texttt{dev1} продолжает работу над другими задачами.

В момент готовности данных \texttt{dev2} посылает их по шине \texttt{data}, а также сообщает о готовности, устанавливая линию прерывания \#RDY. \texttt{dev1} после этого может считывать данные.

Если данную систему моделировать с помощью симуляции с фиксированным шагом, то на каждом такте \texttt{dev1} потребуется проверять значение \#RDY. При симуляции с помощью очереди событий имеется возможность запланировать ответ на момент в будущем, и не «отвлекаться» до его наступления. Последовательность симуляции событий при работе данного сценария такова.
\begin{enumerate*}
    \item \texttt{dev1} запрашивает данные у \texttt{dev2}. Последний вычисляет значение \texttt{data}, а также длительность времени $\Delta t$, в течение которого настоящее устройство было бы занято.
    \item \texttt{dev2} создаёт новое событие \texttt{E} в очереди, размещая его на $\Delta t$ секунд в будущем относительно текущего времени $t_{sim}$.
    \item Симуляция продолжается. В её процессе обрабатываются все события очереди в интервале $[t_{sim}; t_{sim} + \Delta t]$. Эти события могут быть не связаны с процессом взаимодействия \texttt{dev1} и \texttt{dev2}.
    \item Наступает момент обработки \texttt{E}, которое устанавливает \texttt{data} и вызывает обработчик прерывания \#RDY в \texttt{dev1}.
\end{enumerate*}

Довольно легко увидеть, что в качестве \texttt{dev2} может выступать таймер из предыдущего примера: запись \texttt{address} эквивалентна установке \texttt{reference}, ответ \#RDY — прерыванию \#INT; значение \texttt{data} при этом всегда пустое.

\section{Симуляция, управляемая событиями}

Обобщим рассмотренные примеры моделей с очередью событий и опишем универсальную схему организации моделирования последовательности дискретных событий: симуляция, \textit{управляемая событиями} (\abbr event driven). Здесь мы рассмотрим один из её вариантов — \textit{симуляцию дискретных событий} (\abbr discrete event simulation, DES)~\cite{fujimoto-parallel-dist-sim, introduction-to-des, Cain02preciseand},

События интерпретируются как изменения состояний одного или нескольких моделируемых устройств. Моделироваться они будут в порядке возрастания меток времени, когда они должны произойти. В отличие от схемы с фиксированным шагом, продвижение симулируемого времени при этом происходит «скачками», определяемыми интервалом между соседними событиями. 

В практических реализациях для хранения событий используется структура данных «очередь с приоритетами», в которую добавляются новые события, создаваемые при обработке уже существующих. Процесс моделирования сводится к выборке запланированных событий в правильном порядке и их «выполнение» (т.е. изменение состояний согласно тому, что представляют события). На рис. \ref{fig:queue1} приведён пример состояния очереди событий для некоторой системы.

\begin{figure}[htp]
    \centering
    \inputpicture{drawings/queue1}
    \caption[Дискретная симуляция событий]{Дискретная симуляция событий. События привязаны к границам тактов. Показано состояние системы в некоторый момент: несколько событий запланированы в будущем, одно исполняется, при этом оно порождает новое и добавляет его в очередь}
    \label{fig:queue1}
\end{figure}

Значение текущего времени $t_{sim}$ определяется меткой времени последнего обработанного события.

\paragraph{Добавление новых событий.} Приоритетом при добавлении новых событий в описанную выше очередь является метка времени. Таким образом, из очереди первыми извлекаются события с наивысшим приоритетом, т.е. с наименьшим значением метки, а при их равенстве у двух событий первым будет добавленный в очередь раньше, т.е. согласно принципу работы очереди.

% \subsection{Алгоритм DES}
%
% \begin{lstlisting}
% struct event_t {
%     time_t delta;
%     dev_t *device;
%     (*function)();
% }
% uint sim_time = 0;
% while (! empty(queue)) {
%     sim_time += get_delta(queue);
%     evt_t evt = pop(queue);
%     evt.fn(evt.device, queue);
% }
% \end{lstlisting}

\begin{digression}
Важной особенностью DES является разделение архитектурного состояния симуляции, хранимого в составе отдельных объектов, и порядка вызова обработчиков этого состояния, определяемого единой очередью.
\end{digression}

% \begin{digression}
% По своей сути подход DES во многом схож с тем, что мы наблюдаем при отделении класса цифровых электронных схем от аналоговых, когда изучаемым сигналом становится не напряжение на выходах схем, а логический уровень. Несмотря на то, что схемы не перестают быть подчинены законам физики и напряжение на узлах остаётся аналоговой величиной, принимающей непрерывный диапазон значений, цифровые системы проектируются и должны функционировать таким образом, чтобы для их описания было достаточно лишь двух уровней сигнала. При этом мы пренебрегаем всеми переходными процессами, когда сигнал на входах узлов меняется непрерывным способом, а также тем обстоятельством, что скорость их распространения по проводам ограничена. Всё это позволяет значительно упростить анализ поведения системы, так как мы изолируем важные для нас качества и пренебрегаем частью несущественных свойств. Соответственно границы применимости наших суждений о её последующем поведении определяются справедливостью исходных предположений.
% \end{digression}



\paragraph{Удаление событий.} Обработка события может не только порождать новые, но и отменять ещё не обработанные. Пример: описанный ранее таймер с периодом работы 10 тактов получил сигнал о  полном выключении на пятом такте своей работы. Обработка этого события заключается в изменении внутреннего состояния устройства, а также отмене ранее запланированного события, так как оно уже не произойдёт.

\paragraph{Неизменность прошлого.} Порождаемые события не могут попасть в прошлое, т.е. иметь метку времени меньше, чем $t_{sim}$.

\paragraph{Одновременность событий.} Несколько событий могут иметь одинаковую метку времени. Порядок их обработки в таком случае обычно не влияет на корректность симуляции: такие события не связанны причинно-следственной связью. Однако, если не принять мер по упорядочиванию их при симулыяции, то это разрушит её детерминизм. Чаще всего придерживаются правила, что такие события будут обработаны в порядке их добавления в очередь.

% TODO elaborate this paragraph
% \paragraph{Несколько очередей.} В одной симуляции может существовать больше одной очереди. Например, можно иметь одну очередь, хранящую события, привязанные к инструкциям процессора, а другую — к фронтам  тактового генератора. Другой вариант — многопроцессорные системы, в которых с каждым ЦПУ связана своя очередь. Обработка событий из всех очередей происходит в порядке, определяемом принципами работы и требованиями на очерёдность исполнения событий модели.


\section[Два класса моделей]{Два класса моделей}

В этой и предыдущих главах были описаны несколько принципов организации симуляции устройств и их систем. Такие модели можно разделить на два класса по тому признаку, какие силы приводят к изменению состояния участвующих моделей устройств.

\begin{enumerate*}
    \item Внутренние факторы, заложенные в саму модель устройства. Интерпретатор, двоичный транслятор и метод прямого исполнения выполняют шаг за шагом до тех пор, пока не будут остановлены или внешним воздействием (прерыванием, установкой флага исключения и т.п.), или окончанием входных данных (достижение лимита числа исполненных иструкций, времени симуляции и т.п.). Такие модели мы будем называть \textit{исполняющими}, или управляемыми исполнением (\abbr execution driven)
    \item Внешние факторы, стимулирующие модель изменить однократно своё состояние и затем вернуть управление. Любое устройство, входящее в схему DES, является примером такого подхода. Соответствующие им модели — \textit{неисполняющие}, или управляемые событиями (\abbr event driven).
\end{enumerate*}

Можно заметить, что DES не является самым удобным представлением для моделирования центрального процессора с точки зрения обеспечения высокой производительности симуляции. ЦПУ исполняет инструкции на каждом такте (шаге) своей работы. Необходимость часто проверять состояние очереди событий сводит эффективность «улучшенных» техник (двоичная трансляция, прямое исполнение и т.п.) симуляции на нет. 

В реальных системах обычно присутствуют устройства, некоторые из которых удобно моделировать как исполняющие, тогда как остальные должны быть неисполняющими. Необходимо как-то сочетать оба класса, и для этого существует следующее решение.

\begin{enumerate*}
\item Определяется длительность интервала, в течение которого в моделируемой системе не произойдёт никаких событий. Эта величина равна расстоянию от текущего момента до самого раннего ещё не обработанного события в очереди.

\item Управление передаётся в модель процессора, которая исполняется  некоторое время, не превышающее найденное в первом пункте значение. Затем она останавливается и возвращает управление симулятору.

\item Симулируемое время продвигается на число тактов, потраченных процессором. События обрабатываются по модели DES. Затем мы переходим к первому шагу.
\end{enumerate*}

Схема чередования симуляции исполняющего устройства и обработки событий из очереди событий изображена на рис. \ref{fig:queue2}.

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/queue2}
    \caption{Симуляция исполняющего устройства, перемежающаяся с обработкой дискретных событий}
    \label{fig:queue2}
\end{figure}

В каких случаях следует использовать модели каждого из описанных типов? Устройство выгодно представлять исполняющей моделью, если для него верно следующее:
\begin{enumerate*}
    \item Оно меняет своё состояние каждый или почти каждый такт.
    \item События к нему от сторонних устройств приходят в среднем редко (раз в 100–1000 тактов).
    \item Интерес для исследователя представляют внутренние процессы устройства~\cite{fritzson2004principles}.
\end{enumerate*}

Устройство следует симулировать с помощью неисполняющей модели, если ему присущи следующие свойства.
\begin{enumerate*}
    \item Изменение его состояния происходит в среднем редко и асинхронно по отношению к остальным устройствам.
    \item Характер взаимодействия с другими агентами представлятся в виде «запрос–отклик».
    \item Оно может быть представлено как «чёрный ящик» без внутренней структуры.
\end{enumerate*}

Работу системы моделей, состоящих как из исполняющих, так и неисполняющих устройств, можно представить как совместную работу двух или более симуляторов (\textit{косимуляцию}), чередующих своё исполнение таким образом, чтобы выдерживались инварианты, определяющие согласованное течение симулируемого времени (рис. \ref{fig:cosim}).

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/cosim}
    \caption[Косимуляция моделей исполняющих устройств и DES]{Косимуляция моделей исполняющих устройств и DES. При каждой передаче управления соответствующая модель сообщает другой о том, насколько было продвинуто симулируемое время}
    \label{fig:cosim}
\end{figure}

Отметим, что то, какую модель устройства — исполняющую или неисполняющую — создавать, определяется задачами симулятора в целом и этой модели в его составе. Иногда микропроцессор необходимо моделировать очередью событий, но чаще всего он представляется как исполняющая модель. И наоборот, модель некоторого периферийного устройства может быть исполняющей.

\section{Моделирование многопроцессорных систем}\label{sec:mp-simulation}

Рассмотрим случай, когда в моделируемой системе присутствует более одного исполняющего устройства, например несколько процессоров. При этом в реальности они работают одновременно (параллельно), и данный факт необходимо отразить при их моделировании. Отметим, что устройства взаимодействуют всегда с помощью сообщений, время доставки которых конечно и составляет как минимум один такт.

Самое очевидное решение — чередовать исполнение всех процессоров на каждом  шаге. В таком случае их состояние и «локальное» симулируемое время всегда будут отличаться не более чем на один такт.

Недостаток подхода тоже легко понять — такая система будет иметь низкую скорость работы из-за частого переключения моделей и связанного с ними моделируемого состояния. Режимы двоичной трансляции и прямого исполнения невозможно будет задействовать.

Облегчающим обстоятельством является тот факт, что в большинстве случаев нет необходимости выдерживать относительный сдвиг времени процессоров очень малым — ведь в реальности синхронная работа процессоров не наблюдается, и она не гарантируется исполняющимися на них программами. Поэтому мы можем исполнять отдельные процессоры достаточно большими «кусками», перемежая исполнение всех моделей, которые получают возможность задействовать оптимизирующие техники, например ДТ.

Отрезок времени, выделяемый устройству на исполнение, именуется \textit{квотой} (другие названия — квант времени, quota, quantum, time slice). Устройство, находящееся в процессе исполнения в рамках своей квоты, считается текущим. Процесс исполнения многопроцессорной системы проиллюстрирован на рис. \ref{fig:quota-mp-pt1} и \ref{fig:quota-mp-pt2}.

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/quota-mp-pt1}
    \caption[Совместная симуляция нескольких процессоров, часть 1]{Совместная симуляция нескольких процессоров. Отдельные интервалы симуляции чередуются на хозяйском процессоре}
    \label{fig:quota-mp-pt1}
\end{figure}

\begin{figure}[htb]
    \centering
    \inputpicture{drawings/quota-mp-pt2}
    \caption[Совместная симуляция нескольких процессоров, часть 2]{Совместная симуляция нескольких процессоров. В контексте моделируемой системы процесс выглядит как параллельная непрерывная работа}
    \label{fig:quota-mp-pt2}
\end{figure}

\subsection{Замечания к предложенной схеме}

\begin{itemize*}
\item Процессор может исполнить меньше инструкций, чем содержится в выданной ему квоте. Пример причины для ранней остановки — событие во внешнем устройстве, которое необходимо обработать согласно его метке времени. После обработки всех событий, «мешавших» продвижению текущей модели, она либо может продолжить исполнение остатка своей квоты, либо передать управление другому устройству — это зависит от деталей алгоритма планировщика.

\item Не следует увлекаться излишне большими квотами, пытаясь ускорить исполнение — это может негативно повлиять на точность модели, потому что моменты прерывания работы исполняющих моделей являются точками синхронизации состояния всей системы. Между ними каждое устройство работает в полной изоляции, в то время как остальные заморожены и не могут посылать ему никакие сигналы. Если программа, исполняемая в модели, ожидает сообщений от других систем в течение ограниченного времени, то квота не должна превышать это время тайм-аута.

\item В духе модели DES операция переключения текущего исполняющего устройства может быть реализована как псевдособытие, периодически вставляемое в очередь и при своей обработке вызывающее деактивацию текущего и выбор следующего активного процессора.
\end{itemize*}


\input{fullplatform-questions}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

